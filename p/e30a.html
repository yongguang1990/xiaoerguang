<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<meta name="baidu-site-verification" content="QHd039Sny2">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "103791ff"
    });
  daovoice('update');
  </script>



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="-nginx,">





  <link rel="alternate" href="/atom.xml" title="XiaoErGuang" type="application/atom+xml">






<meta name="description" content="Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。 Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。">
<meta name="keywords" content="-nginx">
<meta property="og:type" content="article">
<meta property="og:title" content="nginx">
<meta property="og:url" content="http://xiaoerguang.top/p/e30a.html">
<meta property="og:site_name" content="XiaoErGuang">
<meta property="og:description" content="Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。 Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-2-1.png">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-2-2.png">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-4-1.png">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-4-2.png">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-5-1.png">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-5-2.png">
<meta property="og:updated_time" content="2019-02-14T08:59:26.616Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nginx">
<meta name="twitter:description" content="Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。 Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。">
<meta name="twitter:image" content="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-2-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://xiaoerguang.top/p/e30a.html">





  <title>nginx | XiaoErGuang</title>
  








</head>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://github.com/yongguang1990/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XiaoErGuang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术成就梦想</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于作者">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于作者
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaoerguang.top/p/e30a.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoerguang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoErGuang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">nginx</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-14T16:25:48+08:00">
                2019-02-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-02-14T16:59:26+08:00">
                2019-02-14
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">-linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/p/e30a.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/p/e30a.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/p/e30a.html" class="leancloud_visitors" data-flag-title="nginx">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  47.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  178
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="什么是-Nginx"><a href="#什么是-Nginx" class="headerlink" title="什么是 Nginx"></a>什么是 Nginx</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="什么是-Nginx-1"><a href="#什么是-Nginx-1" class="headerlink" title="什么是 Nginx"></a>什么是 Nginx</h2><p>Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。Nginx 是由俄罗斯人 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过两年半了。Igor Sysoev 在建立的项目时,使用基于 BSD 许可。</p>
<p>英文主页：<a href="http://nginx.net/" target="_blank" rel="noopener">http://nginx.net</a> 。</p>
<p>到 2013 年，目前有很多国内网站采用 Nginx 作为 Web 服务器，如国内知名的新浪、163、腾讯、Discuz、豆瓣等。据 netcraft 统计，Nginx 排名第 3，约占 15% 的份额(参见：<a href="http://news.netcraft.com/archives/category/web-server-survey/" target="_blank" rel="noopener">http://news.netcraft.com/archives/category/web-server-survey/</a> )</p>
<p>Nginx 以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。其拥有匹配 Lighttpd 的性能，同时还没有 Lighttpd 的内存泄漏问题，而且 Lighttpd 的 mod_proxy 也有一些问题并且很久没有更新。</p>
<p>现在，Igor 将源代码以类 BSD 许可证的形式发布。Nginx 因为它的稳定性、丰富的模块库、灵活的配置和低系统资源的消耗而闻名．业界一致认为它是 Apache2.2＋mod_proxy_balancer 的轻量级代替者，不仅是因为响应静态页面的速度非常快，而且它的模块数量达到 Apache 的近 2/3。对 proxy 和 rewrite 模块的支持很彻底，还支持 mod_fcgi、ssl、vhosts ，适合用来做 mongrel clusters 的前端 HTTP 响应。</p>
<h1 id="Nginx-的特点"><a href="#Nginx-的特点" class="headerlink" title="Nginx 的特点"></a>Nginx 的特点</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="Nginx-特点"><a href="#Nginx-特点" class="headerlink" title="Nginx 特点"></a>Nginx 特点</h2><p>Nginx 做为 HTTP 服务器，有以下几项基本特性：</p>
<ul>
<li>处理静态文件，索引文件以及自动索引；打开文件描述符缓冲．</li>
<li>无缓存的反向代理加速，简单的负载均衡和容错．</li>
<li>FastCGI，简单的负载均衡和容错．</li>
<li>模块化的结构。包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等 filter。如果由 FastCGI 或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行运行，而不需要相互等待。</li>
<li>支持 SSL 和 TLSSNI．</li>
</ul>
<p>Nginx 专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 。它支持内核 Poll 模型，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。</p>
<p>Nginx 具有很高的稳定性。其它 HTTP 服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前 apache 一旦上到 200 个以上进程，web响应速度就明显非常缓慢了。而 Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。Nginx 官方表示保持 10,000 个没有活动的连接，它只占 2.5M 内存，所以类似 DOS 这样的攻击对 Nginx 来说基本上是毫无用处的。就稳定性而言,Nginx 比 lighthttpd 更胜一筹。</p>
<p>Nginx 支持热部署。它的启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。</p>
<p>Nginx 采用 master-slave 模型,能够充分利用 SMP 的优势，且能够减少工作进程在磁盘 I/O 的阻塞延迟。当采用 select()/poll() 调用时，还可以限制每个进程的连接数。</p>
<p>Nginx 代码质量非常高，代码很规范，手法成熟，模块扩展也很容易。特别值得一提的是强大的 Upstream 与 Filter 链。Upstream 为诸如 reverse proxy,与其他服务器通信模块的编写奠定了很好的基础。而 Filter 链最酷的部分就是各个 filter 不必等待前一个 filter 执行完毕。它可以把前一个 filter 的输出做为当前 filter 的输入，这有点像 Unix 的管线。这意味着，一个模块可以开始压缩从后端服务器发送过来的请求，且可以在模块接收完后端服务器的整个请求之前把压缩流转向客户端。</p>
<p>Nginx 采用了一些 os 提供的最新特性如对 sendfile (Linux2.2+)，accept-filter (FreeBSD4.1+)，TCP_DEFER_ACCEPT (Linux 2.4+)的支持，从而大大提高了性能。</p>
<p>当然，Nginx 还很年轻，多多少少存在一些问题，比如：Nginx 是俄罗斯人创建，虽然前几年文档比较少，但是目前文档方面比较全面，英文资料居多，中文的资料也比较多，而且有专门的书籍和资料可供查找。</p>
<p>Nginx 的作者和社区都在不断的努力完善，我们有理由相信 Nginx 将继续以高速的增长率来分享轻量级 HTTP 服务器市场，会有一个更美好的未来。</p>
<h1 id="初探-Nginx-架构"><a href="#初探-Nginx-架构" class="headerlink" title="初探 Nginx 架构"></a>初探 Nginx 架构</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="初探-Nginx-架构-1"><a href="#初探-Nginx-架构-1" class="headerlink" title="初探 Nginx 架构"></a>初探 Nginx 架构</h2><p>众所周知，Nginx 性能高，而 Nginx 的高性能与其架构是分不开的。那么 Nginx 究竟是怎么样的呢？这一节我们先来初识一下 Nginx 框架吧。</p>
<p>Nginx 在启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程。我们也可以手动地关掉后台模式，让 Nginx 在前台运行，并且通过配置让 Nginx 取消 master 进程，从而可以使 Nginx 以单进程方式运行。很显然，生产环境下我们肯定不会这么做，所以关闭后台模式，一般是用来调试用的，在后面的章节里面，我们会详细地讲解如何调试 Nginx。所以，我们可以看到，Nginx 是以多进程的方式来工作的，当然 Nginx 也是支持多线程的方式的，只是我们主流的方式还是多进程的方式，也是 Nginx 的默认方式。Nginx 采用多进程的方式有诸多好处，所以我就主要讲解 Nginx 的多进程模式吧。</p>
<p>刚才讲到，Nginx 在启动后，会有一个 master 进程和多个 worker 进程。master 进程主要用来管理 worker 进程，包含：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动新的 worker 进程。而基本的网络事件，则是放在 worker 进程中来处理了。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。worker 进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与 Nginx 的进程模型以及事件处理模型是分不开的。Nginx 的进程模型，可以由下图来表示：</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-2-1.png" alt="img"></p>
<p>在 Nginx 启动后，如果我们要操作 Nginx，要怎么做呢？从上文中我们可以看到，master 来管理 worker 进程，所以我们只需要与 master 进程通信就行了。master 进程会接收来自外界发来的信号，再根据信号做不同的事情。所以我们要控制 Nginx，只需要通过 kill 向 master 进程发送信号就行了。比如<code>kill -HUP pid</code>，则是告诉 Nginx，从容地重启 Nginx，我们一般用这个信号来重启 Nginx，或重新加载配置，因为是从容地重启，因此服务是不中断的。master 进程在接收到 HUP 信号后是怎么做的呢？首先 master 进程在接到信号后，会先重新加载配置文件，然后再启动新的 worker 进程，并向所有老的 worker 进程发送信号，告诉他们可以光荣退休了。新的 worker 在启动后，就开始接收新的请求，而老的 worker 在收到来自 master 的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。当然，直接给 master 进程发送信号，这是比较老的操作方式，Nginx 在 0.8 版本之后，引入了一系列命令行参数，来方便我们管理。比如，<code>./nginx -s reload</code>，就是来重启 Nginx，<code>./nginx -s stop</code>，就是来停止 Nginx 的运行。如何做到的呢？我们还是拿 reload 来说，我们看到，执行命令时，我们是启动一个新的 Nginx 进程，而新的 Nginx 进程在解析到 reload 参数后，就知道我们的目的是控制 Nginx 来重新加载配置文件了，它会向 master 进程发送信号，然后接下来的动作，就和我们直接向 master 进程发送信号一样了。</p>
<p>现在，我们知道了当我们在操作 Nginx 的时候，Nginx 内部做了些什么事情，那么，worker 进程又是如何处理请求的呢？我们前面有提到，worker 进程之间是平等的，每个进程，处理请求的机会也是一样的。当我们提供 80 端口的 http 服务时，一个连接请求过来，每个进程都有可能处理这个连接，怎么做到的呢？首先，每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）之后，然后再 fork 出多个 worker 进程。所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。</p>
<p>那么，Nginx 采用这种进程模型有什么好处呢？当然，好处肯定会很多了。首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。当然，好处还有很多，大家可以慢慢体会。</p>
<p>上面讲了很多关于 Nginx 的进程模型，接下来，我们来看看 Nginx 是如何处理事件的。</p>
<p>有人可能要问了，Nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限啊，多少个 worker 就能处理多少个并发，何来高并发呢？非也，这就是 Nginx 的高明之处，Nginx 采用了异步非阻塞的方式来处理请求，也就是说，Nginx 是可以同时处理成千上万个请求的。想想 apache 的常用工作方式（apache 也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个请求会独占一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求了。这对操作系统来说，是个不小的挑战，线程带来的内存占用非常大，线程的上下文切换带来的 cpu 开销很大，自然性能就上不去了，而这些开销完全是没有意义的。</p>
<p>为什么 Nginx 可以采用异步非阻塞的方式来处理呢，或者异步非阻塞到底是怎么回事呢？我们先回到原点，看看一个请求的完整过程。首先，请求过来，要建立连接，然后再接收数据，接收数据后，再发送数据。具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作，如果不用非阻塞的方式来调用，那就得阻塞调用了，事件没有准备好，那就只能等了，等事件准备好了，你再继续吧。阻塞调用会进入内核等待，cpu 就会让出去给别人用了，对单线程的 worker 来说，显然不合适，当网络事件越多时，大家都在等待呢，cpu 空闲下来没人用，cpu利用率自然上不去了，更别谈高并发了。好吧，你说加进程数，这跟apache的线程模型有什么区别，注意，别增加无谓的上下文切换。所以，在 Nginx 里面，最忌讳阻塞的系统调用了。不要阻塞，那就非阻塞喽。非阻塞就是，事件没有准备好，马上返回 EAGAIN，告诉你，事件还没准备好呢，你慌什么，过会再来吧。好吧，你过一会，再来检查一下事件，直到事件准备好了为止，在这期间，你就可以先去做其它事情，然后再来看看事件好了没。虽然不阻塞了，但你得不时地过来检查一下事件的状态，你可以做更多的事情了，但带来的开销也是不小的。所以，才会有了异步非阻塞的事件处理机制，具体到系统调用就是像 select/poll/epoll/kqueue 这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。这种机制正好解决了我们上面的两个问题，拿 epoll 为例(在后面的例子中，我们多以 epoll 为例子，以代表这一类函数)，当事件没准备好时，放到 epoll 里面，事件准备好了，我们就去读写，当读写返回 EAGAIN 时，我们将它再次加入到 epoll 里面。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在 epoll 里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。 我之前有对连接数进行过测试，在 24G 内存的机器上，处理的并发请求数达到过 200 万。现在的网络服务器基本都采用这种方式，这也是nginx性能高效的主要原因。</p>
<p>我们之前说过，推荐设置 worker 的个数为 cpu 的核数，在这里就很容易理解了，更多的 worker 数，只会导致进程来竞争 cpu 资源了，从而带来不必要的上下文切换。而且，nginx为了更好的利用多核特性，提供了 cpu 亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来 cache 的失效。像这种小的优化在 Nginx 中非常常见，同时也说明了 Nginx 作者的苦心孤诣。比如，Nginx 在做 4 个字节的字符串比较时，会将 4 个字符转换成一个 int 型，再作比较，以减少 cpu 的指令数等等。</p>
<p>现在，知道了 Nginx 为什么会选择这样的进程模型与事件模型了。对于一个基本的 Web 服务器来说，事件通常有三种类型，网络事件、信号、定时器。从上面的讲解中知道，网络事件通过异步非阻塞可以很好的解决掉。如何处理信号与定时器？</p>
<p>首先，信号的处理。对 Nginx 来说，有一些特定的信号，代表着特定的意义。信号会中断掉程序当前的运行，在改变状态后，继续执行。如果是系统调用，则可能会导致系统调用的失败，需要重入。关于信号的处理，大家可以学习一些专业书籍，这里不多说。对于 Nginx 来说，如果nginx正在等待事件（epoll_wait 时），如果程序收到信号，在信号处理函数处理完后，epoll_wait 会返回错误，然后程序可再次进入 epoll_wait 调用。</p>
<p>另外，再来看看定时器。由于 epoll_wait 等函数在调用的时候是可以设置一个超时时间的，所以 Nginx 借助这个超时时间来实现定时器。nginx里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入 epoll_wait前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出 epoll_wait 的超时时间后进入 epoll_wait。所以，当没有事件产生，也没有中断信号时，epoll_wait 会超时，也就是说，定时器事件到了。这时，nginx会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。由此可以看出，当我们写 Nginx 代码时，在处理网络事件的回调函数时，通常做的第一个事情就是判断超时，然后再去处理网络事件。</p>
<p>我们可以用一段伪代码来总结一下 Nginx 的事件处理模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    for t in run_tasks:</span><br><span class="line">        t.handler();</span><br><span class="line">    update_time(&amp;now);</span><br><span class="line">    timeout = ETERNITY;</span><br><span class="line">    for t in wait_tasks: /* sorted already */</span><br><span class="line">        if (t.time &lt;= now) &#123;</span><br><span class="line">            t.timeout_handler();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timeout = t.time - now;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    nevents = poll_function(events, timeout);</span><br><span class="line">    for i in nevents:</span><br><span class="line">        task t;</span><br><span class="line">        if (events[i].type == READ) &#123;</span><br><span class="line">            t.handler = read_handler;</span><br><span class="line">        &#125; else &#123; /* events[i].type == WRITE */</span><br><span class="line">            t.handler = write_handler;</span><br><span class="line">        &#125;</span><br><span class="line">        run_tasks_add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好，本节我们讲了进程模型，事件模型，包括网络事件，信号，定时器事件。</p>
<h1 id="Nginx-基础概念"><a href="#Nginx-基础概念" class="headerlink" title="Nginx 基础概念"></a>Nginx 基础概念</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="Nginx-基础概念-1"><a href="#Nginx-基础概念-1" class="headerlink" title="Nginx 基础概念"></a>Nginx 基础概念</h2><h2 id="connection"><a href="#connection" class="headerlink" title="connection"></a>connection</h2><p>在 Nginx 中 connection 就是对 tcp 连接的封装，其中包括连接的 socket，读事件，写事件。利用 Nginx 封装的 connection，我们可以很方便的使用 Nginx 来处理与连接相关的事情，比如，建立连接，发送与接受数据等。而 Nginx 中的 http 请求的处理就是建立在 connection之上的，所以 Nginx 不仅可以作为一个web服务器，也可以作为邮件服务器。当然，利用 Nginx 提供的 connection，我们可以与任何后端服务打交道。</p>
<p>结合一个 tcp 连接的生命周期，我们看看 Nginx 是如何处理一个连接的。首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 Nginx 的 master 进程里面，先初始化好这个监控的 socket(创建 socket，设置 addrreuse 等选项，绑定到指定的 ip 地址端口，再 listen)，然后再 fork 出多个子进程出来，然后子进程会竞争 accept 新的连接。此时，客户端就可以向 Nginx 发起连接了。当客户端与服务端通过三次握手建立好一个连接后，Nginx 的某一个子进程会 accept 成功，得到这个建立好的连接的 socket，然后创建 Nginx 对连接的封装，即 ngx_connection_t 结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，Nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了。</p>
<p>当然，Nginx 也是可以作为客户端来请求其它 server 的数据的（如 upstream 模块），此时，与其它 server 创建的连接，也封装在 ngx_connection_t 中。作为客户端，Nginx 先获取一个 ngx_connection_t 结构体，然后创建 socket，并设置 socket 的属性（ 比如非阻塞）。然后再通过添加读写事件，调用 connect/read/write 来调用连接，最后关掉连接，并释放 ngx_connection_t。</p>
<p>在 Nginx 中，每个进程会有一个连接数的最大上限，这个上限与系统对 fd 的限制不一样。在操作系统中，通过 <code>ulimit -n</code>，我们可以得到一个进程所能够打开的 fd 的最大数，即 nofile，因为每个 socket 连接会占用掉一个 fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当 fd 用完后，再创建 socket 时，就会失败。Nginx 通过设置 worker_connectons 来设置每个进程支持的最大连接数。如果该值大于 nofile，那么实际的最大连接数是 nofile，Nginx 会有警告。Nginx 在实现时，是通过一个连接池来管理的，每个 worker 进程都有一个独立的连接池，连接池的大小是 worker_connections。这里的连接池里面保存的其实不是真实的连接，它只是一个 worker_connections 大小的一个 ngx_connection_t 结构的数组。并且，Nginx 会通过一个链表 free_connections 来保存所有的空闲 ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。</p>
<p>在这里，很多人会误解 worker_connections 这个参数的意思，认为这个值就是 Nginx 所能建立连接的最大值。其实不然，这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 Nginx 能建立的最大连接数，应该是<code>worker_connections * worker_processes</code>。当然，这里说的是最大连接数，对于 HTTP 请求本地资源来说，能够支持的最大并发数量是<code>worker_connections * worker_processes</code>，而如果是 HTTP 作为反向代理来说，最大并发数量应该是<code>worker_connections * worker_processes/2</code>。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p>
<p>那么，我们前面有说过一个客户端连接过来后，多个空闲的进程，会竞争这个连接，很容易看到，这种竞争会导致不公平，如果某个进程得到 accept 的机会比较多，它的空闲连接很快就用完了，如果不提前做一些控制，当 accept 到一个新的 tcp 连接后，因为无法得到空闲连接，而且无法将此连接转交给其它进程，最终会导致此 tcp 连接得不到处理，就中止掉了。很显然，这是不公平的，有的进程有空余连接，却没有处理机会，有的进程因为没有空余连接，却人为地丢弃连接。那么，如何解决这个问题呢？首先，Nginx 的处理得先打开 accept_mutex 选项，此时，只有获得了 accept_mutex 的进程才会去添加accept事件，也就是说，Nginx会控制进程是否添加 accept 事件。Nginx 使用一个叫 ngx_accept_disabled 的变量来控制是否去竞争 accept_mutex 锁。在第一段代码中，计算 ngx_accept_disabled 的值，这个值是 Nginx 单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个 ngx_accept_disabled 有一个规律，当剩余连接数小于总连接数的八分之一时，其值才大于 0，而且剩余的连接数越小，这个值越大。再看第二段代码，当 ngx_accept_disabled 大于 0 时，不会去尝试获取 accept_mutex 锁，并且将 ngx_accept_disabled 减 1，于是，每次执行到此处时，都会去减 1，直到小于 0。不去获取 accept_mutex 锁，就是等于让出获取连接的机会，很显然可以看出，当空余连接越少时，ngx_accept_disable 越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去 accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，Nginx 就控制了多进程间连接的平衡了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ngx_accept_disabled = ngx_cycle-&gt;connection_n / 8</span><br><span class="line">    - ngx_cycle-&gt;free_connection_n;</span><br><span class="line"></span><br><span class="line">if (ngx_accept_disabled &gt; 0) &#123;</span><br><span class="line">    ngx_accept_disabled--;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_accept_mutex_held) &#123;</span><br><span class="line">        flags |= NGX_POST_EVENTS;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (timer == NGX_TIMER_INFINITE</span><br><span class="line">                || timer &gt; ngx_accept_mutex_delay)</span><br><span class="line">        &#123;</span><br><span class="line">            timer = ngx_accept_mutex_delay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，连接就先介绍到这，本章的目的是介绍基本概念，知道在 Nginx 中连接是个什么东西就行了，而且连接是属于比较高级的用法，在后面的模块开发高级篇会有专门的章节来讲解连接与事件的实现及使用。</p>
<h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><p>这节我们讲 request，在 Nginx 中我们指的是 http 请求，具体到 Nginx 中的数据结构是ngx_http_request_t。ngx_http_request_t 是对一个 http 请求的封装。 我们知道，一个 http 请求，包含请求行、请求头、请求体、响应行、响应头、响应体。</p>
<p>http 请求是典型的请求-响应类型的的网络协议，而 http 是文本协议，所以我们在分析请求行与请求头，以及输出响应行与响应头，往往是一行一行的进行处理。如果我们自己来写一个 http 服务器，通常在一个连接建立好后，客户端会发送请求过来。然后我们读取一行数据，分析出请求行中包含的 method、uri、http_version 信息。然后再一行一行处理请求头，并根据请求 method 与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。在将响应发送给客户端之后，一个完整的请求就处理完了。当然这是最简单的 webserver 的处理方式，其实 Nginx 也是这样做的，只是有一些小小的区别，比如，当请求头读取完成后，就开始进行请求的处理了。Nginx 通过 ngx_http_request_t 来保存解析请求与输出响应相关的数据。</p>
<p>那接下来，简要讲讲 Nginx 是如何处理一个完整的请求的。对于 Nginx 来说，一个请求是从ngx_http_init_request 开始的，在这个函数中，会设置读事件为 ngx_http_process_request_line，也就是说，接下来的网络事件，会由 ngx_http_process_request_line 来执行。从ngx_http_process_request_line 的函数名，我们可以看到，这就是来处理请求行的，正好与之前讲的，处理请求的第一件事就是处理请求行是一致的。通过 ngx_http_read_request_header 来读取请求数据。然后调用 ngx_http_parse_request_line 函数来解析请求行。Nginx 为提高效率，采用状态机来解析请求行，而且在进行 method 的比较时，没有直接使用字符串比较，而是将四个字符转换成一个整型，然后一次比较以减少 cpu 的指令数，这个前面有说过。很多人可能很清楚一个请求行包含请求的方法，uri，版本，却不知道其实在请求行中，也是可以包含有 host 的。比如一个请求 GET <a href="http://www.taobao.com/uri" target="_blank" rel="noopener">http://www.taobao.com/uri</a> HTTP/1.0 这样一个请求行也是合法的，而且 host 是 <a href="http://www.taobao.com，这个时候，Nginx" target="_blank" rel="noopener">www.taobao.com，这个时候，Nginx</a> 会忽略请求头中的 host 域，而以请求行中的这个为准来查找虚拟主机。另外，对于对于 http0.9 版来说，是不支持请求头的，所以这里也是要特别的处理。所以，在后面解析请求头时，协议版本都是 1.0 或 1.1。整个请求行解析到的参数，会保存到 ngx_http_request_t 结构当中。</p>
<p>在解析完请求行后，Nginx 会设置读事件的 handler 为 ngx_http_process_request_headers，然后后续的请求就在 ngx_http_process_request_headers 中进行读取与解析。ngx_http_process_request_headers 函数用来读取请求头，跟请求行一样，还是调用 ngx_http_read_request_header 来读取请求头，调用 ngx_http_parse_header_line 来解析一行请求头，解析到的请求头会保存到 ngx_http_request_t 的域 headers_in 中，headers_in 是一个链表结构，保存所有的请求头。而 HTTP 中有些请求是需要特别处理的，这些请求头与请求处理函数存放在一个映射表里面，即 ngx_http_headers_in，在初始化时，会生成一个 hash 表，当每解析到一个请求头后，就会先在这个 hash 表中查找，如果有找到，则调用相应的处理函数来处理这个请求头。比如:Host 头的处理函数是 ngx_http_process_host。</p>
<p>当 Nginx 解析到两个回车换行符时，就表示请求头的结束，此时就会调用 ngx_http_process_request 来处理请求了。ngx_http_process_request 会设置当前的连接的读写事件处理函数为 ngx_http_request_handler，然后再调用 ngx_http_handler 来真正开始处理一个完整的http请求。这里可能比较奇怪，读写事件处理函数都是ngx_http_request_handler，其实在这个函数中，会根据当前事件是读事件还是写事件，分别调用 ngx_http_request_t 中的 read_event_handler 或者是 write_event_handler。由于此时，我们的请求头已经读取完成了，之前有说过，Nginx 的做法是先不读取请求 body，所以这里面我们设置 read_event_handler 为 ngx_http_block_reading，即不读取数据了。刚才说到，真正开始处理数据，是在 ngx_http_handler 这个函数里面，这个函数会设置 write_event_handler 为 ngx_http_core_run_phases，并执行 ngx_http_core_run_phases 函数。ngx_http_core_run_phases 这个函数将执行多阶段请求处理，Nginx 将一个 http 请求的处理分为多个阶段，那么这个函数就是执行这些阶段来产生数据。因为 ngx_http_core_run_phases 最后会产生数据，所以我们就很容易理解，为什么设置写事件的处理函数为 ngx_http_core_run_phases 了。在这里，我简要说明了一下函数的调用逻辑，我们需要明白最终是调用 ngx_http_core_run_phases 来处理请求，产生的响应头会放在 ngx_http_request_t 的 headers_out 中，这一部分内容，我会放在请求处理流程里面去讲。Nginx 的各种阶段会对请求进行处理，最后会调用 filter 来过滤数据，对数据进行加工，如 truncked 传输、gzip 压缩等。这里的 filter 包括 header filter 与 body filter，即对响应头或响应体进行处理。filter 是一个链表结构，分别有 header filter 与 body filter，先执行 header filter 中的所有 filter，然后再执行 body filter 中的所有 filter。在 header filter 中的最后一个 filter，即 ngx_http_header_filter，这个 filter 将会遍历所有的响应头，最后需要输出的响应头在一个连续的内存，然后调用 ngx_http_write_filter 进行输出。ngx_http_write_filter 是 body filter 中的最后一个，所以 Nginx 首先的 body 信息，在经过一系列的 body filter 之后，最后也会调用 ngx_http_write_filter 来进行输出(有图来说明)。</p>
<p>这里要注意的是，Nginx 会将整个请求头都放在一个 buffer 里面，这个 buffer 的大小通过配置项 client_header_buffer_size 来设置，如果用户的请求头太大，这个 buffer 装不下，那 Nginx 就会重新分配一个新的更大的 buffer 来装请求头，这个大 buffer 可以通过 large_client_header_buffers 来设置，这个 large_buffer 这一组 buffer，比如配置 48k，就是表示有四个 8k 大小的 buffer 可以用。注意，为了保存请求行或请求头的完整性，一个完整的请求行或请求头，需要放在一个连续的内存里面，所以，一个完整的请求行或请求头，只会保存在一个 buffer 里面。这样，如果请求行大于一个 buffer 的大小，就会返回 414 错误，如果一个请求头大小大于一个 buffer 大小，就会返回 400 错误。在了解了这些参数的值，以及 Nginx 实际的做法之后，在应用场景，我们就需要根据实际的需求来调整这些参数，来优化我们的程序了。</p>
<p>处理流程图：</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-2-2.png" alt="img"></p>
<p>以上这些，就是 Nginx 中一个 http 请求的生命周期了。我们再看看与请求相关的一些概念吧。</p>
<h2 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h2><p>当然，在 Nginx 中，对于 http1.0 与 http1.1 也是支持长连接的。什么是长连接呢？我们知道，http 请求是基于 TCP 协议之上的，那么，当客户端在发起请求前，需要先与服务端建立 TCP 连接，而每一次的 TCP 连接是需要三次握手来确定的，如果客户端与服务端之间网络差一点，这三次交互消费的时间会比较多，而且三次交互也会带来网络流量。当然，当连接断开后，也会有四次的交互，当然对用户体验来说就不重要了。而 http 请求是请求应答式的，如果我们能知道每个请求头与响应体的长度，那么我们是可以在一个连接上面执行多个请求的，这就是所谓的长连接，但前提条件是我们先得确定请求头与响应体的长度。对于请求来说，如果当前请求需要有body，如 POST 请求，那么 Nginx 就需要客户端在请求头中指定 content-length 来表明 body 的大小，否则返回 400 错误。也就是说，请求体的长度是确定的，那么响应体的长度呢？先来看看 http 协议中关于响应 body 长度的确定：</p>
<ol>
<li>对于 http1.0 协议来说，如果响应头中有 content-length 头，则以 content-length 的长度就可以知道 body 的长度了，客户端在接收 body 时，就可以依照这个长度来接收数据，接收完后，就表示这个请求完成了。而如果没有 content-length 头，则客户端会一直接收数据，直到服务端主动断开连接，才表示 body 接收完了。</li>
<li>而对于 http1.1 协议来说，如果响应头中的 Transfer-encoding 为 chunked 传输，则表示 body 是流式输出，body 会被分成多个块，每块的开始会标识出当前块的长度，此时，body 不需要通过长度来指定。如果是非 chunked 传输，而且有 content-length，则按照 content-length 来接收数据。否则，如果是非 chunked，并且没有 content-length，则客户端接收数据，直到服务端主动断开连接。</li>
</ol>
<p>从上面，我们可以看到，除了 http1.0 不带 content-length 以及 http1.1 非 chunked 不带 content-length 外，body 的长度是可知的。此时，当服务端在输出完 body 之后，会可以考虑使用长连接。能否使用长连接，也是有条件限制的。如果客户端的请求头中的 connection为close，则表示客户端需要关掉长连接，如果为 keep-alive，则客户端需要打开长连接，如果客户端的请求中没有 connection 这个头，那么根据协议，如果是 http1.0，则默认为 close，如果是 http1.1，则默认为 keep-alive。如果结果为 keepalive，那么，Nginx 在输出完响应体后，会设置当前连接的 keepalive 属性，然后等待客户端下一次请求。当然，Nginx 不可能一直等待下去，如果客户端一直不发数据过来，岂不是一直占用这个连接？所以当 Nginx 设置了 keepalive 等待下一次的请求时，同时也会设置一个最大等待时间，这个时间是通过选项 keepalive_timeout 来配置的，如果配置为 0，则表示关掉 keepalive，此时，http 版本无论是 1.1 还是 1.0，客户端的 connection 不管是 close 还是 keepalive，都会强制为 close。</p>
<p>如果服务端最后的决定是 keepalive 打开，那么在响应的 http 头里面，也会包含有 connection 头域，其值是”Keep-Alive”，否则就是”Close”。如果 connection 值为 close，那么在 Nginx 响应完数据后，会主动关掉连接。所以，对于请求量比较大的 Nginx 来说，关掉 keepalive 最后会产生比较多的 time-wait 状态的 socket。一般来说，当客户端的一次访问，需要多次访问同一个 server 时，打开 keepalive 的优势非常大，比如图片服务器，通常一个网页会包含很多个图片。打开 keepalive 也会大量减少 time-wait 的数量。</p>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><p>在 http1.1 中，引入了一种新的特性，即 pipeline。那么什么是 pipeline 呢？pipeline 其实就是流水线作业，它可以看作为 keepalive 的一种升华，因为 pipeline 也是基于长连接的，目的就是利用一个连接做多次请求。如果客户端要提交多个请求，对于keepalive来说，那么第二个请求，必须要等到第一个请求的响应接收完全后，才能发起，这和 TCP 的停止等待协议是一样的，得到两个响应的时间至少为<code>2*RTT</code>。而对 pipeline 来说，客户端不必等到第一个请求处理完后，就可以马上发起第二个请求。得到两个响应的时间可能能够达到<code>1*RTT</code>。Nginx 是直接支持 pipeline 的，但是，Nginx 对 pipeline 中的多个请求的处理却不是并行的，依然是一个请求接一个请求的处理，只是在处理第一个请求的时候，客户端就可以发起第二个请求。这样，Nginx 利用 pipeline 减少了处理完一个请求后，等待第二个请求的请求头数据的时间。其实 Nginx 的做法很简单，前面说到，Nginx 在读取数据时，会将读取的数据放到一个 buffer 里面，所以，如果 Nginx 在处理完前一个请求后，如果发现 buffer 里面还有数据，就认为剩下的数据是下一个请求的开始，然后就接下来处理下一个请求，否则就设置 keepalive。</p>
<h2 id="lingering-close"><a href="#lingering-close" class="headerlink" title="lingering_close"></a>lingering_close</h2><p>lingering_close，字面意思就是延迟关闭，也就是说，当 Nginx 要关闭连接时，并非立即关闭连接，而是先关闭 tcp 连接的写，再等待一段时间后再关掉连接的读。为什么要这样呢？我们先来看看这样一个场景。Nginx 在接收客户端的请求时，可能由于客户端或服务端出错了，要立即响应错误信息给客户端，而 Nginx 在响应错误信息后，大分部情况下是需要关闭当前连接。Nginx 执行完 write()系统调用把错误信息发送给客户端，write()系统调用返回成功并不表示数据已经发送到客户端，有可能还在 tcp 连接的 write buffer 里。接着如果直接执行 close()系统调用关闭 tcp 连接，内核会首先检查 tcp 的 read buffer 里有没有客户端发送过来的数据留在内核态没有被用户态进程读取，如果有则发送给客户端 RST 报文来关闭 tcp 连接丢弃 write buffer 里的数据，如果没有则等待 write buffer 里的数据发送完毕，然后再经过正常的 4 次分手报文断开连接。所以,当在某些场景下出现 tcp write buffer 里的数据在 write()系统调用之后到 close()系统调用执行之前没有发送完毕，且 tcp read buffer 里面还有数据没有读，close()系统调用会导致客户端收到 RST 报文且不会拿到服务端发送过来的错误信息数据。那客户端肯定会想，这服务器好霸道，动不动就 reset 我的连接，连个错误信息都没有。</p>
<p>在上面这个场景中，我们可以看到，关键点是服务端给客户端发送了 RST 包，导致自己发送的数据在客户端忽略掉了。所以，解决问题的重点是，让服务端别发 RST 包。再想想，我们发送 RST 是因为我们关掉了连接，关掉连接是因为我们不想再处理此连接了，也不会有任何数据产生了。对于全双工的 TCP 连接来说，我们只需要关掉写就行了，读可以继续进行，我们只需要丢掉读到的任何数据就行了，这样的话，当我们关掉连接后，客户端再发过来的数据，就不会再收到 RST 了。当然最终我们还是需要关掉这个读端的，所以我们会设置一个超时时间，在这个时间过后，就关掉读，客户端再发送数据来就不管了，作为服务端我会认为，都这么长时间了，发给你的错误信息也应该读到了，再慢就不关我事了，要怪就怪你 RP 不好了。当然，正常的客户端，在读取到数据后，会关掉连接，此时服务端就会在超时时间内关掉读端。这些正是 lingering_close 所做的事情。协议栈提供 SO_LINGER 这个选项，它的一种配置情况就是来处理 lingering_close 的情况的，不过 Nginx 是自己实现的 lingering_close。lingering_close 存在的意义就是来读取剩下的客户端发来的数据，所以 Nginx 会有一个读超时时间，通过 lingering_timeout 选项来设置，如果在 lingering_timeout 时间内还没有收到数据，则直接关掉连接。Nginx 还支持设置一个总的读取时间，通过 lingering_time 来设置，这个时间也就是 Nginx 在关闭写之后，保留 socket 的时间，客户端需要在这个时间内发送完所有的数据，否则 Nginx 在这个时间过后，会直接关掉连接。当然，Nginx 是支持配置是否打开 lingering_close 选项的，通过 lingering_close 选项来配置。</p>
<p>那么，我们在实际应用中，是否应该打开 lingering_close 呢？这个就没有固定的推荐值了，如 Maxim Dounin所说，lingering_close 的主要作用是保持更好的客户端兼容性，但是却需要消耗更多的额外资源（比如连接会一直占着）。</p>
<p>这节，我们介绍了 Nginx 中，连接与请求的基本概念，下节，我们讲基本的数据结构。</p>
<h1 id="Nginx-基本数据结构"><a href="#Nginx-基本数据结构" class="headerlink" title="Nginx 基本数据结构"></a>Nginx 基本数据结构</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>Nginx 的作者为追求极致的高效，自己实现了很多颇具特色的 Nginx 风格的数据结构以及公共函数。比如，Nginx 提供了带长度的字符串，根据编译器选项优化过的字符串拷贝函数 ngx_copy 等。所以，在我们写 Nginx 模块时，应该尽量调用 Nginx 提供的 api，尽管有些 api 只是对 glibc 的宏定义。本节，我们介绍 string、list、buffer、chain 等一系列最基本的数据结构及相关api的使用技巧以及注意事项。</p>
<h2 id="ngx-str-t"><a href="#ngx-str-t" class="headerlink" title="ngx_str_t"></a>ngx_str_t</h2><p>在 Nginx 源码目录的 src/core 下面的 <code>ngx_string.h|c</code> 里面，包含了字符串的封装以及字符串相关操作的 api。Nginx 提供了一个带长度的字符串结构 ngx_str_t，它的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    size_t      len;</span><br><span class="line">    u_char     *data;</span><br><span class="line">&#125; ngx_str_t;</span><br></pre></td></tr></table></figure>
<p>在结构体当中，data 指向字符串数据的第一个字符，字符串的结束用长度来表示，而不是由<code>&#39;\\0&#39;</code>来表示结束。所以，在写 Nginx 代码时，处理字符串的方法跟我们平时使用有很大的不一样，但要时刻记住，字符串不以<code>&#39;\\0&#39;</code>结束，尽量使用 Nginx 提供的字符串操作的 api 来操作字符串。</p>
<p>那么，Nginx 这样做有什么好处呢？首先，通过长度来表示字符串长度，减少计算字符串长度的次数。其次，Nginx 可以重复引用一段字符串内存，data 可以指向任意内存，长度表示结束，而不用去 copy 一份自己的字符串(因为如果要以<code>&#39;\\0&#39;</code>结束，而不能更改原字符串，所以势必要 copy 一段字符串)。我们在 ngx_http_request_t 结构体的成员中，可以找到很多字符串引用一段内存的例子，比如 request_line、uri、args 等等，这些字符串的 data 部分，都是指向在接收数据时创建 buffer 所指向的内存中，uri，args 就没有必要 copy 一份出来。这样的话，减少了很多不必要的内存分配与拷贝。</p>
<p>正是基于此特性，在 Nginx 中，必须谨慎的去修改一个字符串。在修改字符串时需要认真的去考虑：是否可以修改该字符串；字符串修改后，是否会对其它的引用造成影响。在后面介绍 ngx_unescape_uri 函数的时候，就会看到这一点。但是，使用 Nginx 的字符串会产生一些问题，glibc 提供的很多系统 api 函数大多是通过<code>&#39;\\0&#39;</code>来表示字符串的结束，所以我们在调用系统 api 时，就不能直接传入 str-&gt;data 了。此时，通常的做法是创建一段 str-&gt;len + 1 大小的内存，然后 copy 字符串，最后一个字节置为<code>&#39;\\0&#39;</code>。比较 hack 的做法是，将字符串最后一个字符的后一个字符 backup 一个，然后设置为<code>&#39;\\0&#39;</code>，在做完调用后，再由 backup 改回来，但前提条件是，你得确定这个字符是可以修改的，而且是有内存分配，不会越界，但一般不建议这么做。接下来，看看 Nginx 提供的操作字符串相关的 api。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_string(str)     &#123; sizeof(str) - 1, (u_char *) str &#125;</span><br></pre></td></tr></table></figure>
<p>ngx_string(str) 是一个宏，它通过一个以<code>&#39;\\0&#39;</code>结尾的普通字符串 str 构造一个 Nginx 的字符串，鉴于其中采用 sizeof 操作符计算字符串长度，因此参数必须是一个常量字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_null_string     &#123; 0, NULL &#125;</span><br></pre></td></tr></table></figure>
<p>定义变量时，使用 ngx_null_string 初始化字符串为空字符串，符串的长度为 0，data 为 NULL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_str_set(str, text)                                               \</span><br><span class="line">    (str)-&gt;len = sizeof(text) - 1; (str)-&gt;data = (u_char *) text</span><br></pre></td></tr></table></figure>
<p>ngx_str_set 用于设置字符串 str 为 text，由于使用 sizeof 计算长度，故 text 必须为常量字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_str_null(str)   (str)-&gt;len = 0; (str)-&gt;data = NULL</span><br></pre></td></tr></table></figure>
<p>ngx_str_null 用于设置字符串 str 为空串，长度为 0，data 为 NULL。</p>
<p>上面这四个函数，使用时一定要小心，ngx_string 与 ngx_null_string 是“{<em>，</em>}”格式的，故只能用于赋值时初始化，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx_str_t str = ngx_string(&quot;hello world&quot;);</span><br><span class="line">ngx_str_t str1 = ngx_null_string;</span><br></pre></td></tr></table></figure>
<p>如果向下面这样使用，就会有问题，这里涉及到c语言中对结构体变量赋值操作的语法规则，在此不做介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_str_t str, str1;</span><br><span class="line">str = ngx_string(&quot;hello world&quot;);    // 编译出错</span><br><span class="line">str1 = ngx_null_string;                // 编译出错</span><br></pre></td></tr></table></figure>
<p>这种情况，可以调用 ngx_str_set 与 ngx_str_null 这两个函数来做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_str_t str, str1;</span><br><span class="line">ngx_str_set(&amp;str, &quot;hello world&quot;);    </span><br><span class="line">ngx_str_null(&amp;str1);</span><br></pre></td></tr></table></figure>
<p>按照 C99 标准，您也可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_str_t str, str1;</span><br><span class="line">str  = (ngx_str_t) ngx_string(&quot;hello world&quot;);</span><br><span class="line">str1 = (ngx_str_t) ngx_null_string;</span><br></pre></td></tr></table></figure>
<p>另外要注意的是，ngx_string 与 ngx_str_set 在调用时，传进去的字符串一定是常量字符串，否则会得到意想不到的错误(因为 ngx_str_set 内部使用了 sizeof()，如果传入的是 <code>u_char*</code>，那么计算的是这个指针的长度，而不是字符串的长度)。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_str_t str;</span><br><span class="line">u_char *a = &quot;hello world&quot;;</span><br><span class="line">ngx_str_set(&amp;str, a);    // 问题产生</span><br></pre></td></tr></table></figure>
<p>此外，值得注意的是，由于 ngx_str_set 与 ngx_str_null 实际上是两行语句，故在 if/for/while 等语句中单独使用需要用花括号括起来，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ngx_str_t str;</span><br><span class="line">if (cond)</span><br><span class="line">   ngx_str_set(&amp;str, &quot;true&quot;);     // 问题产生</span><br><span class="line">else</span><br><span class="line">   ngx_str_set(&amp;str, &quot;false&quot;);    // 问题产生</span><br><span class="line">void ngx_strlow(u_char *dst, u_char *src, size_t n);</span><br></pre></td></tr></table></figure>
<p>将 src 的前 n 个字符转换成小写存放在 dst 字符串当中，调用者需要保证 dst 指向的空间大于等于n，且指向的空间必须可写。操作不会对原字符串产生变动。如要更改原字符串，可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx_strlow(str-&gt;data, str-&gt;data, str-&gt;len);</span><br><span class="line">ngx_strncmp(s1, s2, n)</span><br></pre></td></tr></table></figure>
<p>区分大小写的字符串比较，只比较前n个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_strcmp(s1, s2)</span><br></pre></td></tr></table></figure>
<p>区分大小写的不带长度的字符串比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_int_t ngx_strcasecmp(u_char *s1, u_char *s2);</span><br></pre></td></tr></table></figure>
<p>不区分大小写的不带长度的字符串比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_int_t ngx_strncasecmp(u_char *s1, u_char *s2, size_t n);</span><br></pre></td></tr></table></figure>
<p>不区分大小写的带长度的字符串比较，只比较前 n 个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u_char * ngx_cdecl ngx_sprintf(u_char *buf, const char *fmt, ...);</span><br><span class="line">u_char * ngx_cdecl ngx_snprintf(u_char *buf, size_t max, const char *fmt, ...);</span><br><span class="line">u_char * ngx_cdecl ngx_slprintf(u_char *buf, u_char *last, const char *fmt, ...);</span><br></pre></td></tr></table></figure>
<p>上面这三个函数用于字符串格式化，ngx_snprintf 的第二个参数 max 指明 buf 的空间大小，ngx_slprintf 则通过 last 来指明 buf 空间的大小。推荐使用第二个或第三个函数来格式化字符串，ngx_sprintf 函数还是比较危险的，容易产生缓冲区溢出漏洞。在这一系列函数中，Nginx 在兼容 glibc 中格式化字符串的形式之外，还添加了一些方便格式化 Nginx 类型的一些转义字符，比如<code>%V</code>用于格式化 ngx_str_t 结构。在 Nginx 源文件的 ngx_string.c 中有说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * supported formats:</span><br><span class="line"> *    %[0][width][x][X]O        off_t</span><br><span class="line"> *    %[0][width]T              time_t</span><br><span class="line"> *    %[0][width][u][x|X]z      ssize_t/size_t</span><br><span class="line"> *    %[0][width][u][x|X]d      int/u_int</span><br><span class="line"> *    %[0][width][u][x|X]l      long</span><br><span class="line"> *    %[0][width|m][u][x|X]i    ngx_int_t/ngx_uint_t</span><br><span class="line"> *    %[0][width][u][x|X]D      int32_t/uint32_t</span><br><span class="line"> *    %[0][width][u][x|X]L      int64_t/uint64_t</span><br><span class="line"> *    %[0][width|m][u][x|X]A    ngx_atomic_int_t/ngx_atomic_uint_t</span><br><span class="line"> *    %[0][width][.width]f      double, max valid number fits to %18.15f</span><br><span class="line"> *    %P                        ngx_pid_t</span><br><span class="line"> *    %M                        ngx_msec_t</span><br><span class="line"> *    %r                        rlim_t</span><br><span class="line"> *    %p                        void *</span><br><span class="line"> *    %V                        ngx_str_t *</span><br><span class="line"> *    %v                        ngx_variable_value_t *</span><br><span class="line"> *    %s                        null-terminated string</span><br><span class="line"> *    %*s                       length and string</span><br><span class="line"> *    %Z                        &apos;\0&apos;</span><br><span class="line"> *    %N                        &apos;\n&apos;</span><br><span class="line"> *    %c                        char</span><br><span class="line"> *    %%                        %</span><br><span class="line"> *</span><br><span class="line"> *  reserved:</span><br><span class="line"> *    %t                        ptrdiff_t</span><br><span class="line"> *    %S                        null-terminated wchar string</span><br><span class="line"> *    %C                        wchar</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>这里特别要提醒的是，我们最常用于格式化 ngx_str_t 结构，其对应的转义符是<code>%V</code>，传给函数的一定要是指针类型，否则程序就会 coredump 掉。这也是我们最容易犯的错。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx_str_t str = ngx_string(&quot;hello world&quot;);</span><br><span class="line">u_char buffer[1024];</span><br><span class="line">ngx_snprintf(buffer, 1024, &quot;%V&quot;, &amp;str);    // 注意，str取地址</span><br><span class="line">void ngx_encode_base64(ngx_str_t *dst, ngx_str_t *src);</span><br><span class="line">ngx_int_t ngx_decode_base64(ngx_str_t *dst, ngx_str_t *src);</span><br></pre></td></tr></table></figure>
<p>这两个函数用于对 str 进行 base64 编码与解码，调用前，需要保证 dst 中有足够的空间来存放结果，如果不知道具体大小，可先调用 ngx_base64_encoded_length 与 ngx_base64_decoded_length 来预估最大占用空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t ngx_escape_uri(u_char *dst, u_char *src, size_t size,</span><br><span class="line">    ngx_uint_t type);</span><br></pre></td></tr></table></figure>
<p>对 src 进行编码，根据 type 来按不同的方式进行编码，如果 dst 为 NULL，则返回需要转义的字符的数量，由此可得到需要的空间大小。type 的类型可以是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define NGX_ESCAPE_URI         0</span><br><span class="line">#define NGX_ESCAPE_ARGS        1</span><br><span class="line">#define NGX_ESCAPE_HTML        2</span><br><span class="line">#define NGX_ESCAPE_REFRESH     3</span><br><span class="line">#define NGX_ESCAPE_MEMCACHED   4</span><br><span class="line">#define NGX_ESCAPE_MAIL_AUTH   5</span><br><span class="line">void ngx_unescape_uri(u_char **dst, u_char **src, size_t size, ngx_uint_t type);</span><br></pre></td></tr></table></figure>
<p>对 src 进行反编码，type 可以是 0、NGX_UNESCAPE_URI、NGX_UNESCAPE_REDIRECT 这三个值。如果是 0，则表示 src 中的所有字符都要进行转码。如果是 NGX_UNESCAPE_URI 与 NGX_UNESCAPE_REDIRECT，则遇到<code>&#39;?&#39;</code>后就结束了，后面的字符就不管了。而 NGX_UNESCAPE_URI 与 NGX_UNESCAPE_REDIRECT 之间的区别是 NGX_UNESCAPE_URI 对于遇到的需要转码的字符，都会转码，而 NGX_UNESCAPE_REDIRECT 则只会对非可见字符进行转码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t ngx_escape_html(u_char *dst, u_char *src, size_t size);</span><br></pre></td></tr></table></figure>
<p>对 html 标签进行编码。</p>
<p>当然，我这里只介绍了一些常用的 api 的使用，大家可以先熟悉一下，在实际使用过程中，遇到不明白的，最快最直接的方法就是去看源码，看 api 的实现或看 Nginx 自身调用 api 的地方是怎么做的，代码就是最好的文档。</p>
<h2 id="ngx-pool-t"><a href="#ngx-pool-t" class="headerlink" title="ngx_pool_t"></a>ngx_pool_t</h2><p>ngx_pool_t是一个非常重要的数据结构，在很多重要的场合都有使用，很多重要的数据结构也都在使用它。那么它究竟是一个什么东西呢？简单的说，它提供了一种机制，帮助管理一系列的资源（如内存，文件等），使得对这些资源的使用和释放统一进行，免除了使用过程中考虑到对各种各样资源的什么时候释放，是否遗漏了释放的担心。</p>
<p>例如对于内存的管理，如果我们需要使用内存，那么总是从一个 ngx_pool_t 的对象中获取内存，在最终的某个时刻，我们销毁这个 ngx_pool_t 对象，所有这些内存都被释放了。这样我们就不必要对对这些内存进行 malloc 和 free 的操作，不用担心是否某块被malloc出来的内存没有被释放。因为当 ngx_pool_t 对象被销毁的时候，所有从这个对象中分配出来的内存都会被统一释放掉。</p>
<p>再比如我们要使用一系列的文件，但是我们打开以后，最终需要都关闭，那么我们就把这些文件统一登记到一个 ngx_pool_t 对象中，当这个 ngx_pool_t 对象被销毁的时候，所有这些文件都将会被关闭。</p>
<p>从上面举的两个例子中我们可以看出，使用 ngx_pool_t 这个数据结构的时候，所有的资源的释放都在这个对象被销毁的时刻，统一进行了释放，那么就会带来一个问题，就是这些资源的生存周期（或者说被占用的时间）是跟 ngx_pool_t 的生存周期基本一致（ngx_pool_t 也提供了少量操作可以提前释放资源）。从最高效的角度来说，这并不是最好的。比如，我们需要依次使用 A，B，C 三个资源，且使用完 B 的时候，A 就不会再被使用了，使用C的时候 A 和 B 都不会被使用到。如果不使用 ngx_pool_t 来管理这三个资源，那我们可能从系统里面申请 A，使用 A，然后在释放 A。接着申请 B，使用 B，再释放 B。最后申请 C，使用 C，然后释放 C。但是当我们使用一个 ngx_pool_t 对象来管理这三个资源的时候，A，B 和 C 的释放是在最后一起发生的，也就是在使用完 C 以后。诚然，这在客观上增加了程序在一段时间的资源使用量。但是这也减轻了程序员分别管理三个资源的生命周期的工作。这也就是有所得，必有所失的道理。实际上是一个取舍的问题，要看在具体的情况下，你更在乎的是哪个。</p>
<p>可以看一下在 Nginx 里面一个典型的使用 ngx_pool_t 的场景，对于 Nginx 处理的每个 http request, Nginx 会生成一个 ngx_pool_t 对象与这个 http request 关联，所有处理过程中需要申请的资源都从这个 ngx_pool_t 对象中获取，当这个 http request 处理完成以后，所有在处理过程中申请的资源，都将随着这个关联的 ngx_pool_t 对象的销毁而释放。</p>
<p>ngx_pool_t 相关结构及操作被定义在文件<code>src/core/ngx_palloc.h|c</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ngx_pool_s        ngx_pool_t; </span><br><span class="line"></span><br><span class="line">struct ngx_pool_s &#123;</span><br><span class="line">    ngx_pool_data_t       d;</span><br><span class="line">    size_t                max;</span><br><span class="line">    ngx_pool_t           *current;</span><br><span class="line">    ngx_chain_t          *chain;</span><br><span class="line">    ngx_pool_large_t     *large;</span><br><span class="line">    ngx_pool_cleanup_t   *cleanup;</span><br><span class="line">    ngx_log_t            *log;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从 ngx_pool_t 的一般使用者的角度来说，可不用关注 ngx_pool_t 结构中各字段作用。所以这里也不会进行详细的解释，当然在说明某些操作函数的使用的时候，如有必要，会进行说明。</p>
<p>下面我们来分别解释下 ngx_pool_t 的相关操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log);</span><br></pre></td></tr></table></figure>
<p>创建一个初始节点大小为 size 的 pool，log 为后续在该 pool 上进行操作时输出日志的对象。 需要说明的是 size 的选择，size 的大小必须小于等于 NGX_MAX_ALLOC_FROM_POOL，且必须大于 sizeof(ngx_pool_t)。</p>
<p>选择大于 NGX_MAX_ALLOC_FROM_POOL 的值会造成浪费，因为大于该限制的空间不会被用到（只是说在第一个由 ngx_pool_t 对象管理的内存块上的内存，后续的分配如果第一个内存块上的空闲部分已用完，会再分配的）。</p>
<p>选择小于 sizeof(ngx_pool_t)的值会造成程序崩溃。由于初始大小的内存块中要用一部分来存储 ngx_pool_t 这个信息本身。</p>
<p>当一个 ngx_pool_t 对象被创建以后，该对象的 max 字段被赋值为 size-sizeof(ngx_pool_t)和 NGX_MAX_ALLOC_FROM_POOL 这两者中比较小的。后续的从这个 pool 中分配的内存块，在第一块内存使用完成以后，如果要继续分配的话，就需要继续从操作系统申请内存。当内存的大小小于等于 max 字段的时候，则分配新的内存块，链接在 d 这个字段（实际上是 d.next 字段）管理的一条链表上。当要分配的内存块是比 max 大的，那么从系统中申请的内存是被挂接在 large 字段管理的一条链表上。我们暂且把这个称之为大块内存链和小块内存链。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *ngx_palloc(ngx_pool_t *pool, size_t size);</span><br></pre></td></tr></table></figure>
<p>从这个 pool 中分配一块为 size 大小的内存。注意，此函数分配的内存的起始地址按照 NGX_ALIGNMENT 进行了对齐。对齐操作会提高系统处理的速度，但会造成少量内存的浪费。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *ngx_pnalloc(ngx_pool_t *pool, size_t size);</span><br></pre></td></tr></table></figure>
<p>从这个 pool 中分配一块为 size 大小的内存。但是此函数分配的内存并没有像上面的函数那样进行过对齐。</p>
<p>.. code:: c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *ngx_pcalloc(ngx_pool_t *pool, size_t size);</span><br></pre></td></tr></table></figure>
<p>该函数也是分配size大小的内存，并且对分配的内存块进行了清零。内部实际上是转调用ngx_palloc实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment);</span><br></pre></td></tr></table></figure>
<p>按照指定对齐大小 alignment 来申请一块大小为 size 的内存。此处获取的内存不管大小都将被置于大内存块链中管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p);</span><br></pre></td></tr></table></figure>
<p>对于被置于大块内存链，也就是被 large 字段管理的一列内存中的某块进行释放。该函数的实现是顺序遍历 large 管理的大块内存链表。所以效率比较低下。如果在这个链表中找到了这块内存，则释放，并返回 NGX_OK。否则返回 NGX_DECLINED。</p>
<p>由于这个操作效率比较低下，除非必要，也就是说这块内存非常大，确应及时释放，否则一般不需要调用。反正内存在这个 pool 被销毁的时候，总归会都释放掉的嘛！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p, size_t size);</span><br></pre></td></tr></table></figure>
<p>ngx_pool_t 中的 cleanup 字段管理着一个特殊的链表，该链表的每一项都记录着一个特殊的需要释放的资源。对于这个链表中每个节点所包含的资源如何去释放，是自说明的。这也就提供了非常大的灵活性。意味着，ngx_pool_t 不仅仅可以管理内存，通过这个机制，也可以管理任何需要释放的资源，例如，关闭文件，或者删除文件等等。下面我们看一下这个链表每个节点的类型:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct ngx_pool_cleanup_s  ngx_pool_cleanup_t;</span><br><span class="line"><span class="attribute">typedef</span> void (*ngx_pool_cleanup_pt)(void *data);</span><br><span class="line"></span><br><span class="line"><span class="attribute">struct</span> ngx_pool_cleanup_s &#123;</span><br><span class="line">    <span class="attribute">ngx_pool_cleanup_pt</span>   handler;</span><br><span class="line">    <span class="attribute">void</span>                 *data;</span><br><span class="line">    <span class="attribute">ngx_pool_cleanup_t</span>   *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>data: 指明了该节点所对应的资源。</li>
<li>handler: 是一个函数指针，指向一个可以释放 data 所对应资源的函数。该函数只有一个参数，就是 data。</li>
<li>next: 指向该链表中下一个元素。</li>
</ul>
<p>看到这里，ngx_pool_cleanup_add 这个函数的用法，我相信大家都应该有一些明白了。但是这个参数 size 是起什么作用的呢？这个 size 就是要存储这个 data 字段所指向的资源的大小，该函数会为 data 分配 size 大小的空间。</p>
<p>比如我们需要最后删除一个文件。那我们在调用这个函数的时候，把 size 指定为存储文件名的字符串的大小，然后调用这个函数给 cleanup 链表中增加一项。该函数会返回新添加的这个节点。我们然后把这个节点中的 data 字段拷贝为文件名。把 hander 字段赋值为一个删除文件的函数（当然该函数的原型要按照 <code>void (\*ngx_pool_cleanup_pt)(void \*data)</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void ngx_destroy_pool(ngx_pool_t *pool);</span><br></pre></td></tr></table></figure>
<p>该函数就是释放 pool 中持有的所有内存，以及依次调用 cleanup 字段所管理的链表中每个元素的 handler 字段所指向的函数，来释放掉所有该 pool 管理的资源。并且把 pool 指向的 ngx_pool_t 也释放掉了，完全不可用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void ngx_reset_pool(ngx_pool_t *pool);</span><br></pre></td></tr></table></figure>
<p>该函数释放 pool 中所有大块内存链表上的内存，小块内存链上的内存块都修改为可用。但是不会去处理 cleanup链表上的项目。</p>
<h2 id="ngx-array-t"><a href="#ngx-array-t" class="headerlink" title="ngx_array_t"></a>ngx_array_t</h2><p>ngx_array_t 是 Nginx 内部使用的数组结构。Nginx 的数组结构在存储上与大家认知的 C 语言内置的数组有相似性，比如实际上存储数据的区域也是一大块连续的内存。但是数组除了存储数据的内存以外还包含一些元信息来描述相关的一些信息。下面我们从数组的定义上来详细的了解一下。ngx_array_t 的定义位于<code>src/core/ngx_array.c|h</code>里面。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct ngx_array_s       ngx_array_t;</span><br><span class="line"><span class="attribute">struct</span> ngx_array_s &#123;</span><br><span class="line">    <span class="attribute">void</span>        *elts;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>   nelts;</span><br><span class="line">    <span class="attribute">size_t</span>       size;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>   nalloc;</span><br><span class="line">    <span class="attribute">ngx_pool_t</span>  *pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>elts: 指向实际的数据存储区域。</li>
<li>nelts: 数组实际元素个数。</li>
<li>size: 数组单个元素的大小，单位是字节。</li>
<li>nalloc: 数组的容量。表示该数组在不引发扩容的前提下，可以最多存储的元素的个数。当 nelts 增长到达 nalloc 时，如果再往此数组中存储元素，则会引发数组的扩容。数组的容量将会扩展到原有容量的 2 倍大小。实际上是分配新的一块内存，新的一块内存的大小是原有内存大小的 2 倍。原有的数据会被拷贝到新的一块内存中。</li>
<li>pool: 该数组用来分配内存的内存池。</li>
</ul>
<p>下面介绍 ngx_array_t 相关操作函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size);</span><br></pre></td></tr></table></figure>
<p>创建一个新的数组对象，并返回这个对象。</p>
<ul>
<li>p: 数组分配内存使用的内存池；</li>
<li>n: 数组的初始容量大小，即在不扩容的情况下最多可以容纳的元素个数。</li>
<li>size: 单个元素的大小，单位是字节。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void ngx_array_destroy(ngx_array_t *a);</span><br></pre></td></tr></table></figure>
<p>销毁该数组对象，并释放其分配的内存回内存池。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *ngx_array_push(ngx_array_t *a);</span><br></pre></td></tr></table></figure>
<p>在数组 a 上新追加一个元素，并返回指向新元素的指针。需要把返回的指针使用类型转换，转换为具体的类型，然后再给新元素本身或者是各字段（如果数组的元素是复杂类型）赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *ngx_array_push_n(ngx_array_t *a, ngx_uint_t n);</span><br></pre></td></tr></table></figure>
<p>在数组 a 上追加 n 个元素，并返回指向这些追加元素的首个元素的位置的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static ngx_inline ngx_int_t ngx_array_init(ngx_array_t *array, ngx_pool_t *pool, ngx_uint_t n, size_t size);</span><br></pre></td></tr></table></figure>
<p>如果一个数组对象是被分配在堆上的，那么当调用 ngx_array_destroy 销毁以后，如果想再次使用，就可以调用此函数。</p>
<p>如果一个数组对象是被分配在栈上的，那么就需要调用此函数，进行初始化的工作以后，才可以使用。</p>
<p><strong>注意事项</strong>由于使用 ngx_palloc 分配内存，数组在扩容时，旧的内存不会被释放，会造成内存的浪费。因此，最好能提前规划好数组的容量，在创建或者初始化的时候一次搞定，避免多次扩容，造成内存浪费。</p>
<h2 id="ngx-hash-t"><a href="#ngx-hash-t" class="headerlink" title="ngx_hash_t"></a>ngx_hash_t</h2><p>ngx_hash_t 是 Nginx 自己的 hash 表的实现。定义和实现位于<code>src/core/ngx_hash.h|c</code>中。ngx_hash_t 的实现也与数据结构教科书上所描述的 hash 表的实现是大同小异。对于常用的解决冲突的方法有线性探测，二次探测和开链法等。ngx_hash_t 使用的是最常用的一种，也就是开链法，这也是 STL 中的 hash 表使用的方法。</p>
<p>但是 ngx_hash_t 的实现又有其几个显著的特点:</p>
<ol>
<li>ngx_hash_t 不像其他的 hash 表的实现，可以插入删除元素，它只能一次初始化，就构建起整个 hash 表以后，既不能再删除，也不能在插入元素了。</li>
<li>ngx_hash_t 的开链并不是真的开了一个链表，实际上是开了一段连续的存储空间，几乎可以看做是一个数组。这是因为 ngx_hash_t 在初始化的时候，会经历一次预计算的过程，提前把每个桶里面会有多少元素放进去给计算出来，这样就提前知道每个桶的大小了。那么就不需要使用链表，一段连续的存储空间就足够了。这也从一定程度上节省了内存的使用。</li>
</ol>
<p>从上面的描述，我们可以看出来，这个值越大，越造成内存的浪费。就两步，首先是初始化，然后就可以在里面进行查找了。下面我们详细来看一下。</p>
<p>ngx_hash_t 的初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names,</span><br><span class="line">ngx_uint_t nelts);</span><br></pre></td></tr></table></figure>
<p>首先我们来看一下初始化函数。该函数的第一个参数 hinit 是初始化的一些参数的一个集合。 names 是初始化一个 ngx_hash_t 所需要的所有 key 的一个数组。而 nelts 就是 key 的个数。下面先看一下 ngx_hash_init_t 类型，该类型提供了初始化一个 hash 表所需要的一些基本信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct &#123;</span><br><span class="line">    <span class="attribute">ngx_hash_t</span>       *hash;</span><br><span class="line">    <span class="attribute">ngx_hash_key_pt</span>   key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ngx_uint_t</span>        max_size;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>        bucket_size;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">char</span>             *name;</span><br><span class="line">    <span class="attribute">ngx_pool_t</span>       *pool;</span><br><span class="line">    <span class="attribute">ngx_pool_t</span>       *temp_pool;</span><br><span class="line">&#125; ngx_hash_init_t;</span><br></pre></td></tr></table></figure>
<ul>
<li>hash: 该字段如果为 NULL，那么调用完初始化函数后，该字段指向新创建出来的 hash 表。如果该字段不为 NULL，那么在初始的时候，所有的数据被插入了这个字段所指的 hash 表中。</li>
<li>key: 指向从字符串生成 hash 值的 hash 函数。Nginx 的源代码中提供了默认的实现函数 ngx_hash_key_lc。</li>
<li><p>max_size: hash 表中的桶的个数。该字段越大，元素存储时冲突的可能性越小，每个桶中存储的元素会更少，则查询起来的速度更快。当然，这个值越大，越造成内存的浪费也越大，(实际上也浪费不了多少)。</p>
</li>
<li><p>:bucket_size: 每个桶的最大限制大小，单位是字节。如果在初始化一个 hash 表的时候，发现某个桶里面无法存的下所有属于该桶的元素，则 hash 表初始化失败。</p>
<p>name: 该 hash 表的名字。</p>
<p>pool: 该 hash 表分配内存使用的 pool。</p>
<p>temp_pool: 该 hash 表使用的临时 pool，在初始化完成以后，该 pool 可以被释放和销毁掉。</p>
</li>
</ul>
<p>下面来看一下存储 hash 表 key 的数组的结构。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct &#123;</span><br><span class="line">    <span class="attribute">ngx_str_t</span>         key;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>        key_hash;</span><br><span class="line">    <span class="attribute">void</span>             *value;</span><br><span class="line">&#125; ngx_hash_key_t;</span><br></pre></td></tr></table></figure>
<p>key 和 value 的含义显而易见，就不用解释了。key_hash 是对 key 使用 hash 函数计算出来的值。</p>
<p>对这两个结构分析完成以后，我想大家应该都已经明白这个函数应该是如何使用了吧。该函数成功初始化一个 hash 表以后，返回 NGX_OK，否则返回 NGX_ERROR。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len);</span><br></pre></td></tr></table></figure>
<p>在 hash 里面查找 key 对应的 value。实际上这里的 key 是对真正的 key（也就是 name）计算出的 hash 值。len 是 name 的长度。</p>
<p>如果查找成功，则返回指向 value 的指针，否则返回 NULL。</p>
<h2 id="ngx-hash-wildcard-t"><a href="#ngx-hash-wildcard-t" class="headerlink" title="ngx_hash_wildcard_t"></a>ngx_hash_wildcard_t</h2><p>Nginx 为了处理带有通配符的域名的匹配问题，实现了 ngx_hash_wildcard_t 这样的 hash 表。他可以支持两种类型的带有通配符的域名。一种是通配符在前的，例如：<code>\*.abc.com</code>，也可以省略掉星号，直接写成<code>.abc.com</code>。这样的 key，可以匹配 <a href="http://www.abc.com，qqq.www.abc.com" target="_blank" rel="noopener">www.abc.com，qqq.www.abc.com</a> 之类的。另外一种是通配符在末尾的，例如：<code>mail.xxx.\*</code>，请特别注意通配符在末尾的不像位于开始的通配符可以被省略掉。这样的通配符，可以匹配 mail.xxx.com、mail.xxx.com.cn、mail.xxx.net 之类的域名。</p>
<p>有一点必须说明，就是一个 ngx_hash_wildcard_t 类型的 hash 表只能包含通配符在前的key或者是通配符在后的key。不能同时包含两种类型的通配符的 key。ngx_hash_wildcard_t 类型变量的构建是通过函数 ngx_hash_wildcard_init 完成的，而查询是通过函数 ngx_hash_find_wc_head 或者 ngx_hash_find_wc_tail 来做的。ngx_hash_find_wc_head 查询包含通配符在前的 key 的 hash 表的，而 ngx_hash_find_wc_tail 是查询包含通配符在后的 key 的 hash 表的。</p>
<p>下面详细说明这几个函数的用法。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ngx_int_t</span> ngx_hash_wildcard_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names,</span><br><span class="line">    ngx_uint_t nelts);</span><br></pre></td></tr></table></figure>
<p>该函数用来构建一个可以包含通配符 key 的 hash 表。</p>
<ul>
<li>hinit: 构造一个通配符 hash 表的一些参数的一个集合。关于该参数对应的类型的说明，请参见 ngx_hash_t 类型中 ngx_hash_init 函数的说明。</li>
<li>names: 构造此 hash 表的所有的通配符 key 的数组。特别要注意的是这里的 key 已经都是被预处理过的。例如：<code>\*.abc.com</code>或者<code>.abc.com</code>被预处理完成以后，变成了<code>com.abc.</code>。而<code>mail.xxx.\*</code>则被预处理为<code>mail.xxx.</code>。为什么会被处理这样？这里不得不简单地描述一下通配符 hash 表的实现原理。当构造此类型的 hash 表的时候，实际上是构造了一个 hash 表的一个“链表”，是通过 hash 表中的 key “链接”起来的。比如：对于<code>\*.abc.com</code>将会构造出 2 个 hash 表，第一个 hash 表中有一个 key 为 com 的表项，该表项的 value 包含有指向第二个 hash 表的指针，而第二个 hash 表中有一个表项 abc，该表项的 value 包含有指向<code>\*.abc.com</code>对应的 value 的指针。那么查询的时候，比如查询 <a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a> 的时候，先查 com，通过查 com 可以找到第二级的 hash 表，在第二级 hash 表中，再查找 abc，依次类推，直到在某一级的 hash 表中查到的表项对应的 value 对应一个真正的值而非一个指向下一级 hash 表的指针的时候，查询过程结束。<strong>这里有一点需要特别注意的，就是 names 数组中元素的 value 值低两位 bit 必须为 0（有特殊用途）。如果不满足这个条件，这个 hash 表查询不出正确结果。</strong></li>
<li>nelts: names 数组元素的个数。</li>
</ul>
<p>该函数执行成功返回 NGX_OK，否则 NGX_ERROR。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len);</span><br></pre></td></tr></table></figure>
<p>该函数查询包含通配符在前的 key 的 hash 表的。</p>
<ul>
<li>hwc: hash 表对象的指针。</li>
<li>name: 需要查询的域名，例如: <a href="http://www.abc.com。" target="_blank" rel="noopener">www.abc.com。</a></li>
<li>len: name 的长度。</li>
</ul>
<p>该函数返回匹配的通配符对应 value。如果没有查到，返回 NULL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc, u_char *name, size_t len);</span><br></pre></td></tr></table></figure>
<p>该函数查询包含通配符在末尾的 key 的 hash 表的。</p>
<p>参数及返回值请参加上个函数的说明。</p>
<h2 id="ngx-hash-combined-t"><a href="#ngx-hash-combined-t" class="headerlink" title="ngx_hash_combined_t"></a>ngx_hash_combined_t</h2><p>组合类型 hash 表，该 hash 表的定义如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct &#123;</span><br><span class="line">    <span class="attribute">ngx_hash_t</span>            hash;</span><br><span class="line">    <span class="attribute">ngx_hash_wildcard_t</span>  *wc_head;</span><br><span class="line">    <span class="attribute">ngx_hash_wildcard_t</span>  *wc_tail;</span><br><span class="line">&#125; ngx_hash_combined_t;</span><br></pre></td></tr></table></figure>
<p>从其定义显见，该类型实际上包含了三个 hash 表，一个普通 hash 表，一个包含前向通配符的 hash 表和一个包含后向通配符的 hash 表。</p>
<p>Nginx 提供该类型的作用，在于提供一个方便的容器包含三个类型的 hash 表，当有包含通配符的和不包含通配符的一组 key 构建 hash 表以后，以一种方便的方式来查询，你不需要再考虑一个 key 到底是应该到哪个类型的 hash 表里去查了。</p>
<p>构造这样一组合 hash 表的时候，首先定义一个该类型的变量，再分别构造其包含的三个子 hash 表即可。</p>
<p>对于该类型 hash 表的查询，Nginx 提供了一个方便的函数 ngx_hash_find_combined。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">void</span> *ngx_hash_find_combined(ngx_hash_combined_t *hash, ngx_uint_t key,</span><br><span class="line">u_char *name, size_t len);</span><br></pre></td></tr></table></figure>
<p>该函数在此组合 hash 表中，依次查询其三个子 hash 表，看是否匹配，一旦找到，立即返回查找结果，也就是说如果有多个可能匹配，则只返回第一个匹配的结果。</p>
<ul>
<li>hash: 此组合 hash 表对象。</li>
<li>key: 根据 name 计算出的 hash 值。</li>
<li>name: key 的具体内容。</li>
<li>len: name 的长度。</li>
</ul>
<p>返回查询的结果，未查到则返回 NULL。</p>
<h2 id="ngx-hash-keys-arrays-t"><a href="#ngx-hash-keys-arrays-t" class="headerlink" title="ngx_hash_keys_arrays_t"></a>ngx_hash_keys_arrays_t</h2><p>大家看到在构建一个 ngx_hash_wildcard_t 的时候，需要对通配符的哪些 key 进行预处理。这个处理起来比较麻烦。而当有一组 key，这些里面既有无通配符的 key，也有包含通配符的 key 的时候。我们就需要构建三个 hash 表，一个包含普通的 key 的 hash 表，一个包含前向通配符的 hash 表，一个包含后向通配符的 hash 表（或者也可以把这三个 hash 表组合成一个 ngx_hash_combined_t）。在这种情况下，为了让大家方便的构造这些 hash 表，Nginx 提供给了此辅助类型。</p>
<p>该类型以及相关的操作函数也定义在<code>src/core/ngx_hash.h|c</code>里。我们先来看一下该类型的定义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct &#123;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>        hsize;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ngx_pool_t</span>       *pool;</span><br><span class="line">    <span class="attribute">ngx_pool_t</span>       *temp_pool;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ngx_array_t</span>       keys;</span><br><span class="line">    <span class="attribute">ngx_array_t</span>      *keys_hash;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ngx_array_t</span>       dns_wc_head;</span><br><span class="line">    <span class="attribute">ngx_array_t</span>      *dns_wc_head_hash;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ngx_array_t</span>       dns_wc_tail;</span><br><span class="line">    <span class="attribute">ngx_array_t</span>      *dns_wc_tail_hash;</span><br><span class="line">&#125; ngx_hash_keys_arrays_t;</span><br></pre></td></tr></table></figure>
<ul>
<li>hsize: 将要构建的 hash 表的桶的个数。对于使用这个结构中包含的信息构建的三种类型的 hash 表都会使用此参数。</li>
<li>pool: 构建这些 hash 表使用的 pool。</li>
<li>temp_pool: 在构建这个类型以及最终的三个 hash 表过程中可能用到临时 pool。该 temp_pool 可以在构建完成以后，被销毁掉。这里只是存放临时的一些内存消耗。</li>
<li>keys: 存放所有非通配符 key 的数组。</li>
<li>keys_hash: 这是个二维数组，第一个维度代表的是 bucket 的编号，那么 <code>keys_hash[i]</code> 中存放的是所有的 key 算出来的 hash 值对 hsize 取模以后的值为 i 的 key。假设有 3 个 key,分别是 key1,key2 和 key3 假设 hash 值算出来以后对 hsize 取模的值都是 i，那么这三个 key 的值就顺序存放在<code>keys_hash[i][0]</code>,<code>keys_hash[i][1]</code>, <code>keys_hash[i][2]</code>。该值在调用的过程中用来保存和检测是否有冲突的 key 值，也就是是否有重复。</li>
<li>dns_wc_head: 放前向通配符 key 被处理完成以后的值。比如：<code>\*.abc.com</code> 被处理完成以后，变成 “com.abc.” 被存放在此数组中。</li>
<li>dns_wc_tail: 存放后向通配符 key 被处理完成以后的值。比如：<code>mail.xxx.\*</code> 被处理完成以后，变成 “mail.xxx.” 被存放在此数组中。</li>
<li>dns_wc_head_hash: 该值在调用的过程中用来保存和检测是否有冲突的前向通配符的 key 值，也就是是否有重复。</li>
<li>dns_wc_tail_hash: 该值在调用的过程中用来保存和检测是否有冲突的后向通配符的 key 值，也就是是否有重复。</li>
</ul>
<p>在定义一个这个类型的变量，并对字段 pool 和 temp_pool 赋值以后，就可以调用函数 ngx_hash_add_key 把所有的 key 加入到这个结构中了，该函数会自动实现普通 key，带前向通配符的 key 和带后向通配符的 key 的分类和检查，并将这个些值存放到对应的字段中去，然后就可以通过检查这个结构体中的 keys、dns_wc_head、dns_wc_tail 三个数组是否为空，来决定是否构建普通 hash 表，前向通配符 hash 表和后向通配符 hash 表了（在构建这三个类型的 hash 表的时候，可以分别使用 keys、dns_wc_head、dns_wc_tail三个数组）。</p>
<p>构建出这三个 hash 表以后，可以组合在一个 ngx_hash_combined_t 对象中，使用 ngx_hash_find_combined 进行查找。或者是仍然保持三个独立的变量对应这三个 hash 表，自己决定何时以及在哪个 hash 表中进行查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_int_t ngx_hash_keys_array_init(ngx_hash_keys_arrays_t *ha, ngx_uint_t type);</span><br></pre></td></tr></table></figure>
<p>初始化这个结构，主要是对这个结构中的 ngx_array_t 类型的字段进行初始化，成功返回 NGX_OK。</p>
<ul>
<li>ha: 该结构的对象指针。</li>
<li>type: 该字段有 2 个值可选择，即 NGX_HASH_SMALL 和 NGX_HASH_LARGE。用来指明将要建立的 hash 表的类型，如果是 NGX_HASH_SMALL，则有比较小的桶的个数和数组元素大小。NGX_HASH_LARGE 则相反。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ngx_int_t</span> ngx_hash_add_key(ngx_hash_keys_arrays_t *ha, ngx_str_t *key,</span><br><span class="line">void *value, ngx_uint_t flags);</span><br></pre></td></tr></table></figure>
<p>一般是循环调用这个函数，把一组键值对加入到这个结构体中。返回 NGX_OK 是加入成功。返回 NGX_BUSY 意味着key值重复。</p>
<ul>
<li>ha: 该结构的对象指针。</li>
<li>key: 参数名自解释了。</li>
<li>value: 参数名自解释了。</li>
<li>flags: 有两个标志位可以设置，NGX_HASH_WILDCARD_KEY 和 NGX_HASH_READONLY_KEY。同时要设置的使用逻辑与操作符就可以了。NGX_HASH_READONLY_KEY 被设置的时候，在计算 hash 值的时候，key 的值不会被转成小写字符，否则会。NGX_HASH_WILDCARD_KEY 被设置的时候，说明 key 里面可能含有通配符，会进行相应的处理。如果两个标志位都不设置，传 0。</li>
</ul>
<p>有关于这个数据结构的使用，可以参考<code>src/http/ngx_http.c</code>中的 ngx_http_server_names 函数。</p>
<h2 id="ngx-chain-t"><a href="#ngx-chain-t" class="headerlink" title="ngx_chain_t"></a>ngx_chain_t</h2><p>Nginx 的 filter 模块在处理从别的 filter 模块或者是 handler 模块传递过来的数据（实际上就是需要发送给客户端的 http response）。这个传递过来的数据是以一个链表的形式(ngx_chain_t)。而且数据可能被分多次传递过来。也就是多次调用 filter 的处理函数，以不同的 ngx_chain_t。</p>
<p>该结构被定义在<code>src/core/ngx_buf.h|c</code>。下面我们来看一下 ngx_chain_t 的定义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct ngx_chain_s       ngx_chain_t;</span><br><span class="line"></span><br><span class="line"><span class="attribute">struct</span> ngx_chain_s &#123;</span><br><span class="line">    <span class="attribute">ngx_buf_t</span>    *buf;</span><br><span class="line">    <span class="attribute">ngx_chain_t</span>  *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就 2 个字段，next 指向这个链表的下个节点。buf 指向实际的数据。所以在这个链表上追加节点也是非常容易，只要把末尾元素的 next 指针指向新的节点，把新节点的 next 赋值为 NULL 即可。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ngx_chain_t</span> *ngx_alloc_chain_link(ngx_pool_t *pool);</span><br></pre></td></tr></table></figure>
<p>该函数创建一个 ngx_chain_t 的对象，并返回指向对象的指针，失败返回 NULL。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define ngx_free_chain(pool, cl)                                             \</span></span><br><span class="line">    cl-&gt;next = pool-&gt;chain;                                                  \</span><br><span class="line">pool-&gt;chain = cl</span><br></pre></td></tr></table></figure>
<p>该宏释放一个 ngx_chain_t 类型的对象。如果要释放整个 chain，则迭代此链表，对每个节点使用此宏即可。</p>
<p><strong>注意:</strong> 对 ngx_chaint_t 类型的释放，并不是真的释放了内存，而仅仅是把这个对象挂在了这个 pool 对象的一个叫做 chain 的字段对应的 chain 上，以供下次从这个 pool 上分配 ngx_chain_t 类型对象的时候，快速的从这个 pool-&gt;chain上 取下链首元素就返回了，当然，如果这个链是空的，才会真的在这个 pool 上使用 ngx_palloc 函数进行分配。</p>
<h2 id="ngx-buf-t"><a href="#ngx-buf-t" class="headerlink" title="ngx_buf_t"></a>ngx_buf_t</h2><p>这个 ngx_buf_t 就是这个 ngx_chain_t 链表的每个节点的实际数据。该结构实际上是一种抽象的数据结构，它代表某种具体的数据。这个数据可能是指向内存中的某个缓冲区，也可能指向一个文件的某一部分，也可能是一些纯元数据（元数据的作用在于指示这个链表的读取者对读取的数据进行不同的处理）。</p>
<p>该数据结构位于<code>src/core/ngx_buf.h|c</code>文件中。我们来看一下它的定义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">struct</span> ngx_buf_s &#123;</span><br><span class="line">    <span class="attribute">u_char</span>          *pos;</span><br><span class="line">    <span class="attribute">u_char</span>          *<span class="literal">last</span>;</span><br><span class="line">    <span class="attribute">off_t</span>            file_pos;</span><br><span class="line">    <span class="attribute">off_t</span>            file_last;</span><br><span class="line"></span><br><span class="line">    u_char          *start;         /* start of buffer */</span><br><span class="line">    u_char          *end;           /* end of buffer */</span><br><span class="line">    <span class="attribute">ngx_buf_tag_t</span>    tag;</span><br><span class="line">    <span class="attribute">ngx_file_t</span>      *file;</span><br><span class="line">    <span class="attribute">ngx_buf_t</span>       *shadow;</span><br><span class="line"></span><br><span class="line">    /* the buf's content could be changed */</span><br><span class="line">    <span class="attribute">unsigned</span>         temporary:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * the buf's content is in a memory cache or in a read only memory</span><br><span class="line">     * and must not be changed</span><br><span class="line">     */</span><br><span class="line">    <span class="attribute">unsigned</span>         memory:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    /* the buf's content is mmap()ed and must not be changed */</span><br><span class="line">    <span class="attribute">unsigned</span>         mmap:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">unsigned</span>         recycled:<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">unsigned</span>         in_file:<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">unsigned</span>         flush:<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">unsigned</span>         sync:<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">unsigned</span>         last_buf:<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">unsigned</span>         last_in_chain:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">unsigned</span>         last_shadow:<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">unsigned</span>         temp_file:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    /* STUB */ int   num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>pos：当 buf 所指向的数据在内存里的时候，pos 指向的是这段数据开始的位置。</li>
<li>last：当 buf 所指向的数据在内存里的时候，last 指向的是这段数据结束的位置。</li>
<li>file_pos：当 buf 所指向的数据是在文件里的时候，file_pos 指向的是这段数据的开始位置在文件中的偏移量。</li>
<li>file_last：当 buf 所指向的数据是在文件里的时候，file_last 指向的是这段数据的结束位置在文件中的偏移量。</li>
<li>start：当 buf 所指向的数据在内存里的时候，这一整块内存包含的内容可能被包含在多个 buf 中(比如在某段数据中间插入了其他的数据，这一块数据就需要被拆分开)。那么这些 buf 中的 start 和 end 都指向这一块内存的开始地址和结束地址。而 pos 和 last 指向本 buf 所实际包含的数据的开始和结尾。</li>
<li>end：解释参见 start。</li>
<li>tag：实际上是一个<code>void *</code>类型的指针，使用者可以关联任意的对象上去，只要对使用者有意义。</li>
<li>file：当 buf 所包含的内容在文件中时，file字段指向对应的文件对象。</li>
<li>shadow：当这个 buf 完整 copy 了另外一个 buf 的所有字段的时候，那么这两个 buf 指向的实际上是同一块内存，或者是同一个文件的同一部分，此时这两个 buf 的 shadow 字段都是指向对方的。那么对于这样的两个 buf，在释放的时候，就需要使用者特别小心，具体是由哪里释放，要提前考虑好，如果造成资源的多次释放，可能会造成程序崩溃！</li>
<li>temporary：为 1 时表示该 buf 所包含的内容是在一个用户创建的内存块中，并且可以被在 filter 处理的过程中进行变更，而不会造成问题。</li>
<li>memory：为 1 时表示该 buf 所包含的内容是在内存中，但是这些内容却不能被进行处理的 filter 进行变更。</li>
<li>mmap：为 1 时表示该 buf 所包含的内容是在内存中, 是通过 mmap 使用内存映射从文件中映射到内存中的，这些内容却不能被进行处理的 filter 进行变更。</li>
<li>recycled：可以回收的。也就是这个 buf 是可以被释放的。这个字段通常是配合 shadow 字段一起使用的，对于使用 ngx_create_temp_buf 函数创建的 buf，并且是另外一个 buf 的 shadow，那么可以使用这个字段来标示这个buf是可以被释放的。</li>
<li>in_file：为 1 时表示该 buf 所包含的内容是在文件中。</li>
<li>flush：遇到有 flush 字段被设置为 1 的 buf 的 chain，则该 chain 的数据即便不是最后结束的数据（last_buf被设置，标志所有要输出的内容都完了），也会进行输出，不会受 postpone_output 配置的限制，但是会受到发送速率等其他条件的限制。</li>
<li>last_buf：数据被以多个 chain 传递给了过滤器，此字段为 1 表明这是最后一个 buf。</li>
<li>last_in_chain：在当前的 chain 里面，此 buf 是最后一个。特别要注意的是 last_in_chain 的 buf 不一定是last_buf，但是 last_buf 的 buf 一定是 last_in_chain 的。这是因为数据会被以多个 chain 传递给某 个filter 模块。</li>
<li>last_shadow：在创建一个 buf 的 shadow 的时候，通常将新创建的一个 buf 的 last_shadow 置为 1。</li>
<li>temp_file:由于受到内存使用的限制，有时候一些 buf 的内容需要被写到磁盘上的临时文件中去，那么这时，就设置此标志。</li>
</ul>
<p>对于此对象的创建，可以直接在某个 ngx_pool_t 上分配，然后根据需要，给对应的字段赋值。也可以使用定义好的 2 个宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_alloc_buf(pool)  ngx_palloc(pool, sizeof(ngx_buf_t))</span><br><span class="line">#define ngx_calloc_buf(pool) ngx_pcalloc(pool, sizeof(ngx_buf_t))</span><br></pre></td></tr></table></figure>
<p>这两个宏使用类似函数，也是不说自明的。</p>
<p>对于创建 temporary 字段为 1 的 buf（就是其内容可以被后续的 filter 模块进行修改），可以直接使用函数 ngx_create_temp_buf 进行创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool, size_t size);</span><br></pre></td></tr></table></figure>
<p>该函数创建一个 ngx_buf_t 类型的对象，并返回指向这个对象的指针，创建失败返回 NULL。</p>
<p>对于创建的这个对象，它的 start 和 end 指向新分配内存开始和结束的地方。pos 和 last 都指向这块新分配内存的开始处，这样，后续的操作可以在这块新分配的内存上存入数据。</p>
<ul>
<li>pool: 分配该 buf 和 buf 使用的内存所使用的 pool。</li>
<li>size: 该 buf 使用的内存的大小。</li>
</ul>
<p>为了配合对 ngx_buf_t 的使用，Nginx 定义了以下的宏方便操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_buf_in_memory(b)        (b-&gt;temporary || b-&gt;memory || b-&gt;mmap)</span><br></pre></td></tr></table></figure>
<p>返回这个 buf 里面的内容是否在内存里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_buf_in_memory_only(b)   (ngx_buf_in_memory(b) &amp;&amp; !b-&gt;in_file)</span><br></pre></td></tr></table></figure>
<p>返回这个 buf 里面的内容是否仅仅在内存里，并且没有在文件里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_buf_special(b)                                                   \</span><br><span class="line">    ((b-&gt;flush || b-&gt;last_buf || b-&gt;sync)                                    \</span><br><span class="line">     &amp;&amp; !ngx_buf_in_memory(b) &amp;&amp; !b-&gt;in_file)</span><br></pre></td></tr></table></figure>
<p>返回该 buf 是否是一个特殊的 buf，只含有特殊的标志和没有包含真正的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_buf_sync_only(b)                                                 \</span><br><span class="line">    (b-&gt;sync                                                                 \</span><br><span class="line">     &amp;&amp; !ngx_buf_in_memory(b) &amp;&amp; !b-&gt;in_file &amp;&amp; !b-&gt;flush &amp;&amp; !b-&gt;last_buf)</span><br></pre></td></tr></table></figure>
<p>返回该 buf 是否是一个只包含 sync 标志而不包含真正数据的特殊 buf。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_buf_size(b)                                                      \</span><br><span class="line">    (ngx_buf_in_memory(b) ? (off_t) (b-&gt;last - b-&gt;pos):                      \</span><br><span class="line">                            (b-&gt;file_last - b-&gt;file_pos))</span><br></pre></td></tr></table></figure>
<p>返回该 buf 所含数据的大小，不管这个数据是在文件里还是在内存里。</p>
<h2 id="ngx-list-t"><a href="#ngx-list-t" class="headerlink" title="ngx_list_t"></a>ngx_list_t</h2><p>ngx_list_t 顾名思义，看起来好像是一个 list 的数据结构。这样的说法，算对也不算对。因为它符合 list 类型数据结构的一些特点，比如可以添加元素，实现自增长，不会像数组类型的数据结构，受到初始设定的数组容量的限制，并且它跟我们常见的 list 型数据结构也是一样的，内部实现使用了一个链表。</p>
<p>那么它跟我们常见的链表实现的 list 有什么不同呢？不同点就在于它的节点，它的节点不像我们常见的 list 的节点，只能存放一个元素，ngx_list_t 的节点实际上是一个固定大小的数组。</p>
<p>在初始化的时候，我们需要设定元素需要占用的空间大小，每个节点数组的容量大小。在添加元素到这个 list 里面的时候，会在最尾部的节点里的数组上添加元素，如果这个节点的数组存满了，就再增加一个新的节点到这个 list 里面去。</p>
<p>好了，看到这里，大家应该基本上明白这个 list 结构了吧？还不明白也没有关系，下面我们来具体看一下它的定义，这些定义和相关的操作函数定义在<code>src/core/ngx_list.h|c</code>文件中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct &#123;</span><br><span class="line">    <span class="attribute">ngx_list_part_t</span>  *<span class="literal">last</span>;</span><br><span class="line">    <span class="attribute">ngx_list_part_t</span>   part;</span><br><span class="line">    <span class="attribute">size_t</span>            size;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>        nalloc;</span><br><span class="line">    <span class="attribute">ngx_pool_t</span>       *pool;</span><br><span class="line">&#125; ngx_list_t;</span><br></pre></td></tr></table></figure>
<ul>
<li>last: 指向该链表的最后一个节点。</li>
<li>part: 该链表的首个存放具体元素的节点。</li>
<li>size: 链表中存放的具体元素所需内存大小。</li>
<li>nalloc: 每个节点所含的固定大小的数组的容量。</li>
<li>pool: 该 list 使用的分配内存的 pool。</li>
</ul>
<p>好，我们在看一下每个节点的定义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct ngx_list_part_s  ngx_list_part_t;</span><br><span class="line"><span class="attribute">struct</span> ngx_list_part_s &#123;</span><br><span class="line">    <span class="attribute">void</span>             *elts;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>        nelts;</span><br><span class="line">    <span class="attribute">ngx_list_part_t</span>  *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>elts: 节点中存放具体元素的内存的开始地址。</li>
<li>nelts: 节点中已有元素个数。这个值是不能大于链表头节点 ngx_list_t 类型中的 nalloc 字段的。</li>
<li>next: 指向下一个节点。</li>
</ul>
<p>我们来看一下提供的一个操作的函数。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ngx_list_t</span> *ngx_list_create(ngx_pool_t *pool, ngx_uint_t n, size_t size);</span><br></pre></td></tr></table></figure>
<p>该函数创建一个 ngx_list_t 类型的对象，并对该 list 的第一个节点分配存放元素的内存空间。</p>
<ul>
<li>pool: 分配内存使用的 pool。</li>
<li>n: 每个节点（ngx_list_part_t）固定长度的数组的长度，即最多可以存放的元素个数。</li>
<li>size: 每个元素所占用的内存大小。</li>
<li>返回值: 成功返回指向创建的 ngx_list_t 对象的指针，失败返回 NULL。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *ngx_list_push(ngx_list_t *list);</span><br></pre></td></tr></table></figure>
<p>该函数在给定的 list 的尾部追加一个元素，并返回指向新元素存放空间的指针。如果追加失败，则返回 NULL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static ngx_inline ngx_int_t</span><br><span class="line">ngx_list_init(ngx_list_t *list, ngx_pool_t *pool, ngx_uint_t n, size_t size);</span><br></pre></td></tr></table></figure>
<p>该函数是用于 ngx_list_t 类型的对象已经存在，但是其第一个节点存放元素的内存空间还未分配的情况下，可以调用此函数来给这个 list 的首节点来分配存放元素的内存空间。</p>
<p>那么什么时候会出现已经有了 ngx_list_t 类型的对象，而其首节点存放元素的内存尚未分配的情况呢？那就是这个 ngx_list_t 类型的变量并不是通过调用 ngx_list_create 函数创建的。例如：如果某个结构体的一个成员变量是 ngx_list_t 类型的，那么当这个结构体类型的对象被创建出来的时候，这个成员变量也被创建出来了，但是它的首节点的存放元素的内存并未被分配。</p>
<p>总之，如果这个 ngx_list_t 类型的变量，如果不是你通过调用函数 ngx_list_create 创建的，那么就必须调用此函数去初始化，否则，你往这个 list 里追加元素就可能引发不可预知的行为，亦或程序会崩溃!</p>
<h2 id="ngx-queue-t"><a href="#ngx-queue-t" class="headerlink" title="ngx_queue_t"></a>ngx_queue_t</h2><p>ngx_queue_t 是 Nginx 中的双向链表，在 Nginx 源码目录<code>src/core</code>下面的<code>ngx_queue.h|c</code>里面。它的原型如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct ngx_queue_s ngx_queue_t;</span><br><span class="line"></span><br><span class="line"><span class="attribute">struct</span> ngx_queue_s &#123;</span><br><span class="line">    <span class="attribute">ngx_queue_t</span>  *prev;</span><br><span class="line">    <span class="attribute">ngx_queue_t</span>  *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不同于教科书中将链表节点的数据成员声明在链表节点的结构体中，ngx_queue_t 只是声明了前向和后向指针。在使用的时候，我们首先需要定义一个哨兵节点(对于后续具体存放数据的节点，我们称之为数据节点)，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_queue_t free;</span><br></pre></td></tr></table></figure>
<p>接下来需要进行初始化，通过宏 ngx_queue_init()来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_queue_init(&amp;free);</span><br></pre></td></tr></table></figure>
<p>ngx_queue_init()的宏定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_queue_init(q)     \</span><br><span class="line">    (q)-&gt;prev = q;            \</span><br><span class="line">    (q)-&gt;next = q</span><br></pre></td></tr></table></figure>
<p>可见初始的时候哨兵节点的 prev 和 next 都指向自己，因此其实是一个空链表。ngx_queue_empty()可以用来判断一个链表是否为空，其实现也很简单，就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_queue_empty(h)    \</span><br><span class="line">    (h == (h)-&gt;prev)</span><br></pre></td></tr></table></figure>
<p>那么如何声明一个具有数据元素的链表节点呢？只要在相应的结构体中加上一个 ngx_queue_t 的成员就行了。比如 ngx_http_upstream_keepalive_module 中的 ngx_http_upstream_keepalive_cache_t：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct &#123;</span><br><span class="line">    <span class="attribute">ngx_http_upstream_keepalive_srv_conf_t</span>  *conf;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ngx_queue_t</span>                        queue;</span><br><span class="line">    <span class="attribute">ngx_connection_t</span>                  *connection;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">socklen_t</span>                          socklen;</span><br><span class="line">    <span class="attribute">u_char</span>                             sockaddr[NGX_SOCKADDRLEN];</span><br><span class="line">&#125; ngx_http_upstream_keepalive_cache_t;</span><br></pre></td></tr></table></figure>
<p>对于每一个这样的数据节点，可以通过 ngx_queue_insert_head()来添加到链表中，第一个参数是哨兵节点，第二个参数是数据节点，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_upstream_keepalive_cache_t cache;</span><br><span class="line">ngx_queue_insert_head(&amp;free, &amp;cache.queue);</span><br></pre></td></tr></table></figure>
<p>相应的几个宏定义如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define ngx_queue_insert_head(h, x)                         \</span></span><br><span class="line">    (x)-&gt;next = (h)-&gt;next;                                  \</span><br><span class="line">    (x)-&gt;next-&gt;prev = x;                                    \</span><br><span class="line">    (x)-&gt;prev = h;                                          \</span><br><span class="line">    (h)-&gt;next = x</span><br><span class="line"></span><br><span class="line"><span class="comment">#define ngx_queue_insert_after   ngx_queue_insert_head</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define ngx_queue_insert_tail(h, x)                          \</span></span><br><span class="line">    (x)-&gt;prev = (h)-&gt;prev;                                   \</span><br><span class="line">    (x)-&gt;prev-&gt;next = x;                                     \</span><br><span class="line">    (x)-&gt;next = h;                                           \</span><br><span class="line">    (h)-&gt;prev = x</span><br></pre></td></tr></table></figure>
<p>ngx_queue_insert_head() 和 ngx_queue_insert_after() 都是往头部添加节点，ngx_queue_insert_tail() 是往尾部添加节点。从代码可以看出哨兵节点的 prev 指向链表的尾数据节点，next 指向链表的头数据节点。另外 ngx_queue_head() 和 ngx_queue_last() 这两个宏分别可以得到头节点和尾节点。</p>
<p>那假如现在有一个 <code>ngx_queue_t *q</code> 指向的是链表中的数据节点的 queue 成员，如何得到ngx_http_upstream_keepalive_cache_t 的数据呢？ Nginx 提供了 ngx_queue_data() 宏来得到ngx_http_upstream_keepalive_cache_t 的指针，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_upstream_keepalive_cache_t *cache = ngx_queue_data(q,</span><br><span class="line">                             ngx_http_upstream_keepalive_cache_t,</span><br><span class="line">                                                    queue);</span><br></pre></td></tr></table></figure>
<p>也许您已经可以猜到 ngx_queue_data 是通过地址相减来得到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_queue_data(q, type, link)                        \</span><br><span class="line">    (type *) ((u_char *) q - offsetof(type, link))</span><br></pre></td></tr></table></figure>
<p>另外 Nginx 也提供了 ngx_queue_remove()宏来从链表中删除一个数据节点，以及 ngx_queue_add() 用来将一个链表添加到另一个链表。</p>
<h1 id="Nginx-的配置系统"><a href="#Nginx-的配置系统" class="headerlink" title="Nginx 的配置系统"></a>Nginx 的配置系统</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="Nginx-的配置系统-1"><a href="#Nginx-的配置系统-1" class="headerlink" title="Nginx 的配置系统"></a>Nginx 的配置系统</h2><p>Nginx 的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于Nginx 安装目录下的 conf 目录下。</p>
<p>配置文件中以<code>#</code>开始的行，或者是前面有若干空格或者 TAB，然后再跟<code>#</code>的行，都被认为是注释，也就是只对编辑查看文件的用户有意义，程序在读取这些注释行的时候，其实际的内容是被忽略的。</p>
<p>由于除主配置文件 nginx.conf 以外的文件都是在某些情况下才使用的，而只有主配置文件是在任何情况下都被使用的。所以在这里我们就以主配置文件为例，来解释 Nginx 的配置系统。</p>
<p>在 nginx.conf 中，包含若干配置项。每个配置项由配置指令和指令参数 2 个部分构成。指令参数也就是配置指令对应的配置值。</p>
<h2 id="指令概述"><a href="#指令概述" class="headerlink" title="指令概述"></a>指令概述</h2><p>配置指令是一个字符串，可以用单引号或者双引号括起来，也可以不括。但是如果配置指令包含空格，一定要引起来。</p>
<h2 id="指令参数"><a href="#指令参数" class="headerlink" title="指令参数"></a>指令参数</h2><p>指令的参数使用一个或者多个空格或者 TAB 字符与指令分开。指令的参数有一个或者多个 TOKEN 串组成。TOKEN 串之间由空格或者 TAB 键分隔。</p>
<p>TOKEN 串分为简单字符串或者是复合配置块。复合配置块即是由大括号括起来的一堆内容。一个复合配置块中可能包含若干其他的配置指令。</p>
<p>如果一个配置指令的参数全部由简单字符串构成，也就是不包含复合配置块，那么我们就说这个配置指令是一个简单配置项，否则称之为复杂配置项。例如下面这个是一个简单配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page   500 502 503 504  /50x.html;</span><br></pre></td></tr></table></figure>
<p>对于简单配置，配置项的结尾使用分号结束。对于复杂配置项，包含多个 TOKEN 串的，一般都是简单 TOKEN 串放在前面，复合配置块一般位于最后，而且其结尾，并不需要再添加分号。例如下面这个复杂配置项：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   /home/jizhao/nginx-book/build/html;</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指令上下文"><a href="#指令上下文" class="headerlink" title="指令上下文"></a>指令上下文</h2><p>nginx.conf 中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。</p>
<p>当前 Nginx 支持的几个指令上下文：</p>
<ul>
<li>main: Nginx 在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。</li>
<li>http: 与提供 http 服务相关的一些配置参数。例如：是否使用 keepalive 啊，是否使用gzip进行压缩等。</li>
<li>server: http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server，每个 server 通过监听的地址来区分。</li>
<li>location: http 服务中，某些特定的URL对应的一系列配置项。</li>
<li>mail: 实现 email 相关的 SMTP/IMAP/POP3 代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。</li>
</ul>
<p>指令上下文，可能有包含的情况出现。例如：通常 http 上下文和 mail 上下文一定是出现在 main 上下文里的。在一个上下文里，可能包含另外一种类型的上下文多次。例如：如果 http 服务，支持了多个虚拟主机，那么在 http 上下文里，就会出现多个 server 上下文。</p>
<p>我们来看一个示例配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nobody;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log  <span class="literal">info</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;  </span><br><span class="line">    <span class="section">server</span> &#123;  </span><br><span class="line">        <span class="attribute">listen</span>          <span class="number">80</span>;  </span><br><span class="line">        <span class="attribute">server_name</span>     www.linuxidc.com;  </span><br><span class="line">        <span class="attribute">access_log</span>      logs/linuxidc.access.log main;  </span><br><span class="line">        <span class="attribute">location</span> / &#123;  </span><br><span class="line">            <span class="attribute">index</span> index.html;  </span><br><span class="line">            <span class="attribute">root</span>  /var/www/linuxidc.com/htdocs;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;  </span><br><span class="line">        <span class="attribute">listen</span>          <span class="number">80</span>;  </span><br><span class="line">        <span class="attribute">server_name</span>     www.Androidj.com;  </span><br><span class="line">        <span class="attribute">access_log</span>      logs/androidj.access.log main;  </span><br><span class="line">        <span class="attribute">location</span> / &#123;  </span><br><span class="line">            <span class="attribute">index</span> index.html;  </span><br><span class="line">            <span class="attribute">root</span>  /var/www/androidj.com/htdocs;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">mail</span> &#123;</span><br><span class="line">    <span class="attribute">auth_http</span>  <span class="number">127.0.0.1:80</span>/auth.php;</span><br><span class="line">    <span class="attribute">pop3_capabilities</span>  <span class="string">"TOP"</span>  <span class="string">"USER"</span>;</span><br><span class="line">    <span class="attribute">imap_capabilities</span>  <span class="string">"IMAP4rev1"</span>  <span class="string">"UIDPLUS"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>     <span class="number">110</span>;</span><br><span class="line">        <span class="attribute">protocol</span>   pop3;</span><br><span class="line">        <span class="attribute">proxy</span>      <span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>      <span class="number">25</span>;</span><br><span class="line">        <span class="attribute">protocol</span>    smtp;</span><br><span class="line">        <span class="attribute">proxy</span>       <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">smtp_auth</span>   login plain;</span><br><span class="line">        <span class="attribute">xclient</span>     <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个配置中，上面提到个五种配置指令上下文都存在。</p>
<p>存在于 main 上下文中的配置指令如下:</p>
<ul>
<li>user</li>
<li>worker_processes</li>
<li>error_log</li>
<li>events</li>
<li>http</li>
<li>mail</li>
</ul>
<p>存在于 http 上下文中的指令如下:</p>
<ul>
<li>server</li>
</ul>
<p>存在于 mail 上下文中的指令如下：</p>
<ul>
<li>server</li>
<li>auth_http</li>
<li>imap_capabilities</li>
</ul>
<p>存在于 server 上下文中的配置指令如下：</p>
<ul>
<li>listen</li>
<li>server_name</li>
<li>access_log</li>
<li>location</li>
<li>protocol</li>
<li>proxy</li>
<li>smtp_auth</li>
<li>xclient</li>
</ul>
<p>存在于 location 上下文中的指令如下：</p>
<ul>
<li>index</li>
<li>root</li>
</ul>
<p>当然，这里只是一些示例。具体有哪些配置指令，以及这些配置指令可以出现在什么样的上下文中，需要参考 Nginx 的使用文档</p>
<h1 id="Nginx-的模块化体系结构"><a href="#Nginx-的模块化体系结构" class="headerlink" title="Nginx 的模块化体系结构"></a>Nginx 的模块化体系结构</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="Nginx-的模块化体系结构-1"><a href="#Nginx-的模块化体系结构-1" class="headerlink" title="Nginx 的模块化体系结构"></a>Nginx 的模块化体系结构</h2><p>Nginx 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。为了便于描述，下文中我们将使用 Nginx core 来称呼 Nginx 的核心功能部分。</p>
<p>Nginx 提供了 Web 服务器的基础功能，同时提供了 Web 服务反向代理，Email 服务反向代理功能。Nginx core实现了底层的通讯协议，为其他模块和 Nginx 进程构建了基本的运行时环境，并且构建了其他各模块的协作基础。除此之外，或者说大部分与协议相关的，或者应用相关的功能都是在这些模块中所实现的。</p>
<h2 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h2><p>Nginx 将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现 SSI 的模块，实现与上游服务器进行通讯的模块，实现与 FastCGI 服务进行通讯的模块。</p>
<p>有两个模块比较特殊，他们居于 Nginx core 和各功能模块的中间。这两个模块就是 http 模块和 mail 模块。这 2 个模块在 Nginx core 之上实现了另外一层抽象，处理与 HTTP 协议和 Email 相关协议（SMTP/POP3/IMAP）有关的事件，并且确保这些事件能被以正确的顺序调用其他的一些功能模块。</p>
<p>目前 HTTP 协议是被实现在 http 模块中的，但是有可能将来被剥离到一个单独的模块中，以扩展 Nginx 支持 SPDY 协议。</p>
<h2 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a>模块的分类</h2><p>Nginx 的模块根据其功能基本上可以分为以下几种类型：</p>
<ul>
<li>event module: 搭建了独立于操作系统的事件处理机制的框架，及提供了各具体事件的处理。包括 ngx_events_module， ngx_event_core_module和ngx_epoll_module 等。Nginx 具体使用何种事件处理模块，这依赖于具体的操作系统和编译选项。</li>
<li>phase handler: 此类型的模块也被直接称为 handler 模块。主要负责处理客户端请求并产生待响应内容，比如 ngx_http_static_module 模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。</li>
<li>output filter: 也称为 filter 模块，主要是负责对输出的内容进行处理，可以对输出进行修改。例如，可以实现对输出的所有 html 页面增加预定义的 footbar 一类的工作，或者对输出的图片的 URL 进行替换之类的工作。</li>
<li>upstream: upstream 模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream 模块是一种特殊的 handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。</li>
<li>load-balancer: 负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器。</li>
</ul>
<h1 id="Nginx-的请求处理"><a href="#Nginx-的请求处理" class="headerlink" title="Nginx 的请求处理"></a>Nginx 的请求处理</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="Nginx-的请求处理-1"><a href="#Nginx-的请求处理-1" class="headerlink" title="Nginx 的请求处理"></a>Nginx 的请求处理</h2><p>Nginx 使用一个多进程模型来对外提供服务，其中一个 master 进程，多个 worker 进程。master 进程负责管理 Nginx 本身和其他 worker 进程。</p>
<p>所有实际上的业务处理逻辑都在 worker 进程。worker 进程中有一个函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个 Nginx 服务被停止。</p>
<p>worker 进程中，ngx_worker_process_cycle()函数就是这个无限循环的处理函数。在这个函数中，一个请求的简单处理流程如下：</p>
<ul>
<li>操作系统提供的机制（例如 epoll, kqueue 等）产生相关的事件。</li>
<li>接收和处理这些事件，如是接受到数据，则产生更高层的 request 对象。</li>
<li>处理 request 的 header 和 body。</li>
<li>产生响应，并发送回客户端。</li>
<li>完成 request 的处理。</li>
<li>重新初始化定时器及其他事件。</li>
</ul>
<h2 id="请求的处理流程"><a href="#请求的处理流程" class="headerlink" title="请求的处理流程"></a>请求的处理流程</h2><p>为了让大家更好的了解 Nginx 中请求处理过程，我们以 HTTP Request 为例，来做一下详细地说明。</p>
<p>从 Nginx 的内部来看，一个 HTTP Request 的处理过程涉及到以下几个阶段。</p>
<ul>
<li>初始化 HTTP Request（读取来自客户端的数据，生成 HTTP Request 对象，该对象含有该请求所有的信息）。</li>
<li>处理请求头。</li>
<li>处理请求体。</li>
<li>如果有的话，调用与此请求（URL 或者 Location）关联的 handler。</li>
<li>依次调用各 phase handler 进行处理。</li>
</ul>
<p>在这里，我们需要了解一下 phase handler 这个概念。phase 字面的意思，就是阶段。所以 phase handlers 也就好理解了，就是包含若干个处理阶段的一些 handler。</p>
<p>在每一个阶段，包含有若干个 handler，再处理到某个阶段的时候，依次调用该阶段的 handler 对 HTTP Request 进行处理。</p>
<p>通常情况下，一个 phase handler 对这个 request 进行处理，并产生一些输出。通常 phase handler 是与定义在配置文件中的某个 location 相关联的。</p>
<p>一个 phase handler 通常执行以下几项任务：</p>
<ul>
<li>获取 location 配置。</li>
<li>产生适当的响应。</li>
<li>发送 response header。</li>
<li>发送 response body。</li>
</ul>
<p>当 Nginx 读取到一个 HTTP Request 的 header 的时候，Nginx 首先查找与这个请求关联的虚拟主机的配置。如果找到了这个虚拟主机的配置，那么通常情况下，这个 HTTP Request 将会经过以下几个阶段的处理（phase handlers）：</p>
<ul>
<li>NGX_HTTP_POST_READ_PHASE: 读取请求内容阶段</li>
<li>NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段</li>
<li>NGX_HTTP_FIND_CONFIG_PHASE: 配置查找阶段:</li>
<li>NGX_HTTP_REWRITE_PHASE: Location请求地址重写阶段</li>
<li>NGX_HTTP_POST_REWRITE_PHASE: 请求地址重写提交阶段</li>
<li>NGX_HTTP_PREACCESS_PHASE: 访问权限检查准备阶段</li>
<li>NGX_HTTP_ACCESS_PHASE: 访问权限检查阶段</li>
<li>NGX_HTTP_POST_ACCESS_PHASE: 访问权限检查提交阶段</li>
<li>NGX_HTTP_TRY_FILES_PHASE: 配置项 try_files 处理阶段</li>
<li>NGX_HTTP_CONTENT_PHASE: 内容产生阶段</li>
<li>NGX_HTTP_LOG_PHASE: 日志模块处理阶段</li>
</ul>
<p>在内容产生阶段，为了给一个 request 产生正确的响应，Nginx 必须把这个 request 交给一个合适的 content handler 去处理。如果这个 request 对应的 location 在配置文件中被明确指定了一个 content handler，那么Nginx 就可以通过对 location 的匹配，直接找到这个对应的 handler，并把这个 request 交给这个 content handler 去处理。这样的配置指令包括像，perl，flv，proxy_pass，mp4等。</p>
<p>如果一个 request 对应的 location 并没有直接有配置的 content handler，那么 Nginx 依次尝试:</p>
<ul>
<li>如果一个 location 里面有配置 random_index on，那么随机选择一个文件，发送给客户端。</li>
<li>如果一个 location 里面有配置 index 指令，那么发送 index 指令指明的文件，给客户端。</li>
<li>如果一个 location 里面有配置 autoindex on，那么就发送请求地址对应的服务端路径下的文件列表给客户端。</li>
<li>如果这个 request 对应的 location 上有设置 gzip_static on，那么就查找是否有对应的<code>.gz</code>文件存在，有的话，就发送这个给客户端（客户端支持 gzip 的情况下）。</li>
<li>请求的 URI 如果对应一个静态文件，static module 就发送静态文件的内容到客户端。</li>
</ul>
<p>内容产生阶段完成以后，生成的输出会被传递到 filter 模块去进行处理。filter 模块也是与 location 相关的。所有的 fiter 模块都被组织成一条链。输出会依次穿越所有的 filter，直到有一个 filter 模块的返回值表明已经处理完成。</p>
<p>这里列举几个常见的 filter 模块，例如：</p>
<ul>
<li>server-side includes。</li>
<li>XSLT filtering。</li>
<li>图像缩放之类的。</li>
<li>gzip 压缩。</li>
</ul>
<p>在所有的 filter 中，有几个 filter 模块需要关注一下。按照调用的顺序依次说明如下：</p>
<ul>
<li>write: 写输出到客户端，实际上是写到连接对应的 socket 上。</li>
<li>postpone: 这个 filter 是负责 subrequest 的，也就是子请求的。</li>
<li>copy: 将一些需要复制的 buf(文件或者内存)重新复制一份然后交给剩余的 body filter 处理。</li>
</ul>
<h1 id="Nginx-handler-模块简介"><a href="#Nginx-handler-模块简介" class="headerlink" title="Nginx handler 模块简介"></a>Nginx handler 模块简介</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="handler-模块简介"><a href="#handler-模块简介" class="headerlink" title="handler 模块简介"></a>handler 模块简介</h2><p>相信大家在看了前一章的模块概述以后，都对 Nginx 的模块有了一个基本的认识。基本上作为第三方开发者最可能开发的就是三种类型的模块，即 handler，filter 和 load-balancer。Handler 模块就是接受来自客户端的请求并产生输出的模块。有些地方说 upstream 模块实际上也是一种 handler 模块，只不过它产生的内容来自于从后端服务器获取的，而非在本机产生的。</p>
<p>在上一章提到，配置文件中使用 location 指令可以配置 content handler 模块，当 Nginx 系统启动的时候，每个 handler 模块都有一次机会把自己关联到对应的 location上。如果有多个 handler 模块都关联了同一个 location，那么实际上只有一个 handler 模块真正会起作用。当然大多数情况下，模块开发人员都会避免出现这种情况。</p>
<p>handler 模块处理的结果通常有三种情况: 处理成功，处理失败（处理的时候发生了错误）或者是拒绝去处理。在拒绝处理的情况下，这个 location 的处理就会由默认的 handler 模块来进行处理。例如，当请求一个静态文件的时候，如果关联到这个 location 上的一个 handler 模块拒绝处理，就会由默认的 ngx_http_static_module 模块进行处理，该模块是一个典型的 handler 模块。</p>
<p>本章主要讲述的是如何编写 handler 模块，在研究 handler 模块编写之前先来了解一下模块的一些基本数据结构。</p>
<h1 id="Nginx-模块的基本结构"><a href="#Nginx-模块的基本结构" class="headerlink" title="Nginx 模块的基本结构"></a>Nginx 模块的基本结构</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="模块的基本结构"><a href="#模块的基本结构" class="headerlink" title="模块的基本结构"></a>模块的基本结构</h2><p>在这一节我们将会对通常的模块开发过程中，每个模块所包含的一些常用的部分进行说明。这些部分有些是必须的，有些不是必须的。同时这里所列出的这些东西对于其他类型的模块，例如 filter 模块等也都是相同的。</p>
<h2 id="模块配置结构"><a href="#模块配置结构" class="headerlink" title="模块配置结构"></a>模块配置结构</h2><p>基本上每个模块都会提供一些配置指令，以便于用户可以通过配置来控制该模块的行为。那么这些配置信息怎么存储呢？那就需要定义该模块的配置结构来进行存储。</p>
<p>大家都知道 Nginx 的配置信息分成了几个作用域(scope,有时也称作上下文)，这就是 main，server 以及 location。同样的每个模块提供的配置指令也可以出现在这几个作用域里。那对于这三个作用域的配置信息，每个模块就需要定义三个不同的数据结构去进行存储。当然，不是每个模块都会在这三个作用域都提供配置指令的。那么也就不一定每个模块都需要定义三个数据结构去存储这些配置信息了。视模块的实现而言，需要几个就定义几个。</p>
<p>有一点需要特别注意的就是，在模块的开发过程中，我们最好使用 Nginx 原有的命名习惯。这样跟原代码的契合度更高，看起来也更舒服。</p>
<p>对于模块配置信息的定义，命名习惯是<code>ngx_http_&lt;module name&gt;_(main|srv|loc)_conf_t</code>。这里有个例子，就是从我们后面将要展示给大家的 hello module 中截取的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    ngx_str_t hello_string;</span><br><span class="line">    ngx_int_t hello_counter;</span><br><span class="line">&#125;ngx_http_hello_loc_conf_t;</span><br></pre></td></tr></table></figure>
<h2 id="模块配置指令"><a href="#模块配置指令" class="headerlink" title="模块配置指令"></a>模块配置指令</h2><p>一个模块的配置指令是定义在一个静态数组中的。同样地，我们来看一下从 hello module 中截取的模块配置指令的定义。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">static</span> ngx_command_t ngx_http_hello_commands[] = &#123;</span><br><span class="line">   &#123; </span><br><span class="line">        ngx_string("hello_string"),</span><br><span class="line">        NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1,</span><br><span class="line">        ngx_http_hello_string,</span><br><span class="line">        NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">        offsetof(ngx_http_hello_loc_conf_t, hello_string),</span><br><span class="line">        <span class="attribute">NULL</span> &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; </span><br><span class="line">        ngx_string("hello_counter"),</span><br><span class="line">        NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,</span><br><span class="line">        ngx_http_hello_counter,</span><br><span class="line">        NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">        offsetof(ngx_http_hello_loc_conf_t, hello_counter),</span><br><span class="line">        <span class="attribute">NULL</span> &#125;,               </span><br><span class="line"></span><br><span class="line">    ngx_null_command</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实看这个定义，就基本能看出来一些信息。例如，我们是定义了两个配置指令，一个是叫 hello_string，可以接受一个参数，或者是没有参数。另外一个命令是 hello_counter，接受一个 NGX_CONF_FLAG 类型的参数。除此之外，似乎看起来有点迷惑。没有关系，我们来详细看一下 ngx_command_t，一旦我们了解这个结构的详细信息，那么我相信上述这个定义所表达的所有信息就不言自明了。</p>
<p>ngx_command_t 的定义，位于<code>src/core/ngx_conf_file.h</code>中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">struct</span> ngx_command_s &#123;</span><br><span class="line">    <span class="attribute">ngx_str_t</span>             name;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            type;</span><br><span class="line">    <span class="attribute">char</span>               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            conf;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            offset;</span><br><span class="line">    <span class="attribute">void</span>                 *post;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>name</strong>: 配置指令的名称。</p>
<p><strong>type</strong>: 该配置的类型，其实更准确一点说，是该配置指令属性的集合。Nginx 提供了很多预定义的属性值（一些宏定义），通过逻辑或运算符可组合在一起，形成对这个配置指令的详细的说明。下面列出可在这里使用的预定义属性值及说明。</p>
<ul>
<li>NGX_CONF_NOARGS：配置指令不接受任何参数。</li>
<li>NGX_CONF_TAKE1：配置指令接受 1 个参数。</li>
<li>NGX_CONF_TAKE2：配置指令接受 2 个参数。</li>
<li>NGX_CONF_TAKE3：配置指令接受 3 个参数。</li>
<li>NGX_CONF_TAKE4：配置指令接受 4 个参数。</li>
<li>NGX_CONF_TAKE5：配置指令接受 5 个参数。</li>
<li>NGX_CONF_TAKE6：配置指令接受 6 个参数。</li>
<li>NGX_CONF_TAKE7：配置指令接受 7 个参数。</li>
</ul>
<p>可以组合多个属性，比如一个指令即可以不填参数，也可以接受1个或者2个参数。那么就是<code>NGX_CONF_NOARGS|NGX_CONF_TAKE1|NGX_CONF_TAKE2</code>。如果写上面三个属性在一起，你觉得麻烦，那么没有关系，Nginx 提供了一些定义，使用起来更简洁。</p>
<ul>
<li>NGX_CONF_TAKE12：配置指令接受 1 个或者 2 个参数。</li>
<li>NGX_CONF_TAKE13：配置指令接受 1 个或者 3 个参数。</li>
<li>NGX_CONF_TAKE23：配置指令接受 2 个或者 3 个参数。</li>
<li>NGX_CONF_TAKE123：配置指令接受 1 个或者 2 个或者 3 参数。</li>
<li>NGX_CONF_TAKE1234：配置指令接受 1 个或者 2 个或者 3 个或者 4 个参数。</li>
<li>NGX_CONF_1MORE：配置指令接受至少一个参数。</li>
<li>NGX_CONF_2MORE：配置指令接受至少两个参数。</li>
<li>NGX_CONF_MULTI: 配置指令可以接受多个参数，即个数不定。</li>
<li>NGX_CONF_BLOCK：配置指令可以接受的值是一个配置信息块。也就是一对大括号括起来的内容。里面可以再包括很多的配置指令。比如常见的 server 指令就是这个属性的。</li>
<li>NGX_CONF_FLAG：配置指令可以接受的值是”on”或者”off”，最终会被转成 bool 值。</li>
<li>NGX_CONF_ANY：配置指令可以接受的任意的参数值。一个或者多个，或者”on”或者”off”，或者是配置块。</li>
</ul>
<p>最后要说明的是，无论如何，Nginx 的配置指令的参数个数不可以超过 NGX_CONF_MAX_ARGS 个。目前这个值被定义为 8，也就是不能超过 8 个参数值。</p>
<p>下面介绍一组说明配置指令可以出现的位置的属性。</p>
<ul>
<li>NGX_DIRECT_CONF：可以出现在配置文件中最外层。例如已经提供的配置指令 daemon，master_process 等。</li>
<li>NGX_MAIN_CONF: http、mail、events、error_log 等。</li>
<li>NGX_ANY_CONF: 该配置指令可以出现在任意配置级别上。</li>
</ul>
<p>对于我们编写的大多数模块而言，都是在处理http相关的事情，也就是所谓的都是NGX_HTTP_MODULE，对于这样类型的模块，其配置可能出现的位置也是分为直接出现在http里面，以及其他位置。</p>
<ul>
<li>NGX_HTTP_MAIN_CONF: 可以直接出现在 http 配置指令里。</li>
<li>NGX_HTTP_SRV_CONF: 可以出现在 http 里面的 server 配置指令里。</li>
<li>NGX_HTTP_LOC_CONF: 可以出现在 http server 块里面的 location 配置指令里。</li>
<li>NGX_HTTP_UPS_CONF: 可以出现在 http 里面的 upstream 配置指令里。</li>
<li>NGX_HTTP_SIF_CONF: 可以出现在 http 里面的 server 配置指令里的 if 语句所在的 block 中。</li>
<li>NGX_HTTP_LMT_CONF: 可以出现在 http 里面的 limit_except 指令的 block 中。</li>
<li>NGX_HTTP_LIF_CONF: 可以出现在 http server 块里面的 location 配置指令里的 if 语句所在的 block 中。</li>
</ul>
<p><strong>set</strong>: 这是一个函数指针，当 Nginx 在解析配置的时候，如果遇到这个配置指令，将会把读取到的值传递给这个函数进行分解处理。因为具体每个配置指令的值如何处理，只有定义这个配置指令的人是最清楚的。来看一下这个函数指针要求的函数原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);</span><br></pre></td></tr></table></figure>
<p>先看该函数的返回值，处理成功时，返回 NGX_OK，否则返回 NGX_CONF_ERROR 或者是一个自定义的错误信息的字符串。</p>
<p>再看一下这个函数被调用的时候，传入的三个参数。</p>
<ul>
<li>cf: 该参数里面保存从配置文件读取到的原始字符串以及相关的一些信息。特别注意的是这个参数的args字段是一个 ngx_str_t类型的数组，该数组的首个元素是这个配置指令本身，第二个元素是指令的第一个参数，第三个元素是第二个参数，依次类推。</li>
<li>cmd: 这个配置指令对应的 ngx_command_t 结构。</li>
<li>conf: 就是定义的存储这个配置值的结构体，比如在上面展示的那个 ngx_http_hello_loc_conf_t。当解析这个 hello_string 变量的时候，传入的 conf 就指向一个 ngx_http_hello_loc_conf_t 类型的变量。用户在处理的时候可以使用类型转换，转换成自己知道的类型，再进行字段的赋值。</li>
</ul>
<p>为了更加方便的实现对配置指令参数的读取，Nginx 已经默认提供了对一些标准类型的参数进行读取的函数，可以直接赋值给 set 字段使用。下面来看一下这些已经实现的 set 类型函数。</p>
<ul>
<li>ngx_conf_set_flag_slot： 读取 NGX_CONF_FLAG 类型的参数。</li>
<li>ngx_conf_set_str_slot:读取字符串类型的参数。</li>
<li>ngx_conf_set_str_array_slot: 读取字符串数组类型的参数。</li>
<li>ngx_conf_set_keyval_slot： 读取键值对类型的参数。</li>
<li>ngx_conf_set_num_slot: 读取整数类型(有符号整数 ngx_int_t)的参数。</li>
<li>ngx_conf_set_size_slot:读取 size_t 类型的参数，也就是无符号数。</li>
<li>ngx_conf_set_off_slot: 读取 off_t 类型的参数。</li>
<li>ngx_conf_set_msec_slot: 读取毫秒值类型的参数。</li>
<li>ngx_conf_set_sec_slot: 读取秒值类型的参数。</li>
<li>ngx_conf_set_bufs_slot： 读取的参数值是 2 个，一个是 buf 的个数，一个是 buf 的大小。例如： output_buffers 1 128k;</li>
<li>ngx_conf_set_enum_slot: 读取枚举类型的参数，将其转换成整数 ngx_uint_t 类型。</li>
<li>ngx_conf_set_bitmask_slot: 读取参数的值，并将这些参数的值以 bit 位的形式存储。例如：HttpDavModule 模块的 dav_methods 指令。</li>
</ul>
<p><strong>conf</strong>: 该字段被 NGX_HTTP_MODULE 类型模块所用 (我们编写的基本上都是 NGX_HTTP_MOUDLE，只有一些 Nginx 核心模块是非 NGX_HTTP_MODULE)，该字段指定当前配置项存储的内存位置。实际上是使用哪个内存池的问题。因为 http 模块对所有 http 模块所要保存的配置信息，划分了 main, server 和 location 三个地方进行存储，每个地方都有一个内存池用来分配存储这些信息的内存。这里可能的值为 NGX_HTTP_MAIN_CONF_OFFSET、NGX_HTTP_SRV_CONF_OFFSET 或 NGX_HTTP_LOC_CONF_OFFSET。当然也可以直接置为 0，就是 NGX_HTTP_MAIN_CONF_OFFSET。</p>
<p><strong>offset</strong>: 指定该配置项值的精确存放位置，一般指定为某一个结构体变量的字段偏移。因为对于配置信息的存储，一般我们都是定义个结构体来存储的。那么比如我们定义了一个结构体 A，该项配置的值需要存储到该结构体的 b 字段。那么在这里就可以填写为 offsetof(A, b)。对于有些配置项，它的值不需要保存或者是需要保存到更为复杂的结构中时，这里可以设置为 0。</p>
<p><strong>post</strong>: 该字段存储一个指针。可以指向任何一个在读取配置过程中需要的数据，以便于进行配置读取的处理。大多数时候，都不需要，所以简单地设为 0 即可。</p>
<p>看到这里，应该就比较清楚了。ngx_http_hello_commands 这个数组每 5 个元素为一组，用来描述一个配置项的所有情况。那么如果有多个配置项，只要按照需要再增加 5 个对应的元素对新的配置项进行说明。</p>
<p><strong>需要注意的是，就是在ngx_http_hello_commands这个数组定义的最后，都要加一个ngx_null_command作为结尾。</strong></p>
<h2 id="模块上下文结构"><a href="#模块上下文结构" class="headerlink" title="模块上下文结构"></a>模块上下文结构</h2><p>这是一个 ngx_http_module_t 类型的静态变量。这个变量实际上是提供一组回调函数指针，这些函数有在创建存储配置信息的对象的函数，也有在创建前和创建后会调用的函数。这些函数都将被 Nginx 在合适的时间进行调用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct &#123;</span><br><span class="line">    <span class="attribute">ngx_int_t</span>   (*preconfiguration)(ngx_conf_t *cf);</span><br><span class="line">    <span class="attribute">ngx_int_t</span>   (*postconfiguration)(ngx_conf_t *cf);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">void</span>       *(*create_main_conf)(ngx_conf_t *cf);</span><br><span class="line">    <span class="attribute">char</span>       *(*init_main_conf)(ngx_conf_t *cf, void *conf);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">void</span>       *(*create_srv_conf)(ngx_conf_t *cf);</span><br><span class="line">    <span class="attribute">char</span>       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">void</span>       *(*create_loc_conf)(ngx_conf_t *cf);</span><br><span class="line">    <span class="attribute">char</span>       *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf);</span><br><span class="line">&#125; ngx_http_module_t;</span><br></pre></td></tr></table></figure>
<ul>
<li>preconfiguration: 在创建和读取该模块的配置信息之前被调用。</li>
<li>postconfiguration: 在创建和读取该模块的配置信息之后被调用。</li>
<li>create_main_conf: 调用该函数创建本模块位于 http block 的配置信息存储结构。该函数成功的时候，返回创建的配置对象。失败的话，返回 NULL。</li>
<li>init_main_conf: 调用该函数初始化本模块位于 http block 的配置信息存储结构。该函数成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。</li>
<li>create_srv_conf: 调用该函数创建本模块位于 http server block 的配置信息存储结构，每个 server block 会创建一个。该函数成功的时候，返回创建的配置对象。失败的话，返回 NULL。</li>
<li>merge_srv_conf: 因为有些配置指令既可以出现在 http block，也可以出现在 http server block 中。那么遇到这种情况，每个 server 都会有自己存储结构来存储该 server 的配置，但是在这种情况下 http block 中的配置与 server block 中的配置信息发生冲突的时候，就需要调用此函数进行合并，该函数并非必须提供，当预计到绝对不会发生需要合并的情况的时候，就无需提供。当然为了安全起见还是建议提供。该函数执行成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。</li>
<li>create_loc_conf: 调用该函数创建本模块位于 location block 的配置信息存储结构。每个在配置中指明的 location 创建一个。该函数执行成功，返回创建的配置对象。失败的话，返回 NULL。</li>
<li>merge_loc_conf: 与 merge_srv_conf 类似，这个也是进行配置值合并的地方。该函数成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。</li>
</ul>
<p>Nginx 里面的配置信息都是上下一层层的嵌套的，对于具体某个 location 的话，对于同一个配置，如果当前层次没有定义，那么就使用上层的配置，否则使用当前层次的配置。</p>
<p>这些配置信息一般默认都应该设为一个未初始化的值，针对这个需求，Nginx 定义了一系列的宏定义来代表各种配置所对应数据类型的未初始化值，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define NGX_CONF_UNSET       -1</span></span><br><span class="line"><span class="comment">#define NGX_CONF_UNSET_UINT  (ngx_uint_t) -1</span></span><br><span class="line"><span class="comment">#define NGX_CONF_UNSET_PTR   (void *) -1</span></span><br><span class="line"><span class="comment">#define NGX_CONF_UNSET_SIZE  (size_t) -1</span></span><br><span class="line"><span class="comment">#define NGX_CONF_UNSET_MSEC  (ngx_msec_t) -1</span></span><br></pre></td></tr></table></figure>
<p>又因为对于配置项的合并，逻辑都类似，也就是前面已经说过的，如果在本层次已经配置了，也就是配置项的值已经被读取进来了（那么这些配置项的值就不会等于上面已经定义的那些 UNSET 的值），就使用本层次的值作为定义合并的结果，否则，使用上层的值，如果上层的值也是这些UNSET类的值，那就赋值为默认值，否则就使用上层的值作为合并的结果。对于这样类似的操作，Nginx 定义了一些宏操作来做这些事情，我们来看其中一个的定义。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define ngx_conf_merge_uint_value(conf, prev, default) \</span></span><br><span class="line">    if (conf == NGX_CONF_UNSET_UINT) &#123;      \</span><br><span class="line">        conf = (prev == NGX_CONF_UNSET_UINT) ? default : prev; \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>显而易见，这个逻辑确实比较简单，所以其它的宏定义也类似，我们就列具其中的一部分吧。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx_conf_merge_value</span><br><span class="line">ngx_conf_merge_ptr_value</span><br><span class="line">ngx_conf_merge_uint_value</span><br><span class="line">ngx_conf_merge_msec_value</span><br><span class="line">ngx_conf_merge_sec_value</span><br></pre></td></tr></table></figure>
<p>等等。</p>
<p>下面来看一下 hello 模块的模块上下文的定义，加深一下印象。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">static</span> ngx_http_module_t ngx_http_hello_module_ctx = &#123;</span><br><span class="line">    NULL,                          /* preconfiguration */</span><br><span class="line">    ngx_http_hello_init,           /* postconfiguration */</span><br><span class="line"></span><br><span class="line">    NULL,                          /* create main configuration */</span><br><span class="line">    NULL,                          /* init main configuration */</span><br><span class="line"></span><br><span class="line">    NULL,                          /* create server configuration */</span><br><span class="line">    NULL,                          /* merge server configuration */</span><br><span class="line"></span><br><span class="line">    ngx_http_hello_create_loc_conf, /* create location configuration */</span><br><span class="line">    <span class="attribute">NULL</span>                        /* merge location configuration */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：这里并没有提供 merge_loc_conf 函数，因为我们这个模块的配置指令已经确定只出现在 NGX_HTTP_LOC_CONF 中这一个层次上，不会发生需要合并的情况。</strong></p>
<h2 id="模块的定义"><a href="#模块的定义" class="headerlink" title="模块的定义"></a>模块的定义</h2><p>对于开发一个模块来说，我们都需要定义一个 ngx_module_t 类型的变量来说明这个模块本身的信息，从某种意义上来说，这是这个模块最重要的一个信息，它告诉了 Nginx 这个模块的一些信息，上面定义的配置信息，还有模块上下文信息，都是通过这个结构来告诉 Nginx 系统的，也就是加载模块的上层代码，都需要通过定义的这个结构，来获取这些信息。</p>
<p>我们先来看下 ngx_module_t 的定义</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct ngx_module_s      ngx_module_t;</span><br><span class="line"><span class="attribute">struct</span> ngx_module_s &#123;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            ctx_index;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            index;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            spare0;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            spare1;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            abi_compatibility;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            major_version;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            minor_version;</span><br><span class="line">    <span class="attribute">void</span>                 *ctx;</span><br><span class="line">    <span class="attribute">ngx_command_t</span>        *commands;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>            type;</span><br><span class="line">    <span class="attribute">ngx_int_t</span>           (*init_master)(ngx_log_t *log);</span><br><span class="line">    <span class="attribute">ngx_int_t</span>           (*init_module)(ngx_cycle_t *cycle);</span><br><span class="line">    <span class="attribute">ngx_int_t</span>           (*init_process)(ngx_cycle_t *cycle);</span><br><span class="line">    <span class="attribute">ngx_int_t</span>           (*init_thread)(ngx_cycle_t *cycle);</span><br><span class="line">    <span class="attribute">void</span>                (*exit_thread)(ngx_cycle_t *cycle);</span><br><span class="line">    <span class="attribute">void</span>                (*exit_process)(ngx_cycle_t *cycle);</span><br><span class="line">    <span class="attribute">void</span>                (*exit_master)(ngx_cycle_t *cycle);</span><br><span class="line">    <span class="attribute">uintptr_t</span>             spare_hook0;</span><br><span class="line">    <span class="attribute">uintptr_t</span>             spare_hook1;</span><br><span class="line">    <span class="attribute">uintptr_t</span>             spare_hook2;</span><br><span class="line">    <span class="attribute">uintptr_t</span>             spare_hook3;</span><br><span class="line">    <span class="attribute">uintptr_t</span>             spare_hook4;</span><br><span class="line">    <span class="attribute">uintptr_t</span>             spare_hook5;</span><br><span class="line">    <span class="attribute">uintptr_t</span>             spare_hook6;</span><br><span class="line">    <span class="attribute">uintptr_t</span>             spare_hook7;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define NGX_NUMBER_MAJOR  3</span></span><br><span class="line"><span class="comment">#define NGX_NUMBER_MINOR  1</span></span><br><span class="line"><span class="comment">#define NGX_MODULE_V1          0, 0, 0, 0,                              \</span></span><br><span class="line">    NGX_DSO_ABI_COMPATIBILITY, NGX_NUMBER_MAJOR, NGX_NUMBER_MINOR</span><br><span class="line"><span class="comment">#define NGX_MODULE_V1_PADDING  0, 0, 0, 0, 0, 0, 0, 0</span></span><br></pre></td></tr></table></figure>
<p>再看一下 hello 模块的模块定义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ngx_module_t</span> ngx_http_hello_module = &#123;</span><br><span class="line">    NGX_MODULE_V1,</span><br><span class="line">    &amp;ngx_http_hello_module_ctx,    /* module context */</span><br><span class="line">    ngx_http_hello_commands,       /* module directives */</span><br><span class="line">    NGX_HTTP_MODULE,               /* module type */</span><br><span class="line">    NULL,                          /* init master */</span><br><span class="line">    NULL,                          /* init module */</span><br><span class="line">    NULL,                          /* init process */</span><br><span class="line">    NULL,                          /* init thread */</span><br><span class="line">    NULL,                          /* exit thread */</span><br><span class="line">    NULL,                          /* exit process */</span><br><span class="line">    NULL,                          /* exit master */</span><br><span class="line">    NGX_MODULE_V1_PADDING</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模块可以提供一些回调函数给 Nginx，当 Nginx 在创建进程线程或者结束进程线程时进行调用。但大多数模块在这些时刻并不需要做什么，所以都简单赋值为 NULL。</p>
<h1 id="Nginx-handler-模块的基本结构"><a href="#Nginx-handler-模块的基本结构" class="headerlink" title="Nginx handler 模块的基本结构"></a>Nginx handler 模块的基本结构</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="handler-模块的基本结构"><a href="#handler-模块的基本结构" class="headerlink" title="handler 模块的基本结构"></a>handler 模块的基本结构</h2><p>除了上一节介绍的模块的基本结构以外，handler 模块必须提供一个真正的处理函数，这个函数负责对来自客户端请求的真正处理。这个函数的处理，既可以选择自己直接生成内容，也可以选择拒绝处理，由后续的 handler 去进行处理，或者是选择丢给后续的 filter 进行处理。来看一下这个函数的原型申明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef ngx_int_t (*ngx_http_handler_pt)(ngx_http_request_t *r);</span><br></pre></td></tr></table></figure>
<p>r 是 http 请求。里面包含请求所有的信息，这里不详细说明了，可以参考别的章节的介绍。 该函数处理成功返回 NGX_OK，处理发生错误返回 NGX_ERROR，拒绝处理（留给后续的 handler 进行处理）返回 NGX_DECLINE。 返回 NGX_OK 也就代表给客户端的响应已经生成好了，否则返回 NGX_ERROR 就发生错误了。</p>
<h1 id="Nginx-handler-模块的挂载"><a href="#Nginx-handler-模块的挂载" class="headerlink" title="Nginx handler 模块的挂载"></a>Nginx handler 模块的挂载</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="handler-模块的挂载"><a href="#handler-模块的挂载" class="headerlink" title="handler 模块的挂载"></a>handler 模块的挂载</h2><p>handler 模块真正的处理函数通过两种方式挂载到处理过程中，一种方式就是按处理阶段挂载;另外一种挂载方式就是按需挂载。</p>
<h2 id="按处理阶段挂载"><a href="#按处理阶段挂载" class="headerlink" title="按处理阶段挂载"></a>按处理阶段挂载</h2><p>为了更精细地控制对于客户端请求的处理过程，Nginx 把这个处理过程划分成了 11 个阶段。他们从前到后，依次列举如下：</p>
<ul>
<li>NGX_HTTP_POST_READ_PHASE: 读取请求内容阶段</li>
<li>NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段</li>
<li>NGX_HTTP_FIND_CONFIG_PHASE: 配置查找阶段:</li>
<li>NGX_HTTP_REWRITE_PHASE: Location 请求地址重写阶段</li>
<li>NGX_HTTP_POST_REWRITE_PHASE: 请求地址重写提交阶段</li>
<li>NGX_HTTP_PREACCESS_PHASE: 访问权限检查准备阶段</li>
<li>NGX_HTTP_ACCESS_PHASE: 访问权限检查阶段</li>
<li>NGX_HTTP_POST_ACCESS_PHASE: 访问权限检查提交阶段</li>
<li>NGX_HTTP_TRY_FILES_PHASE: 配置项 try_files 处理阶段</li>
<li>NGX_HTTP_CONTENT_PHASE: 内容产生阶段</li>
<li>NGX_HTTP_LOG_PHASE: 日志模块处理阶段</li>
</ul>
<p>一般情况下，我们自定义的模块，大多数是挂载在 NGX_HTTP_CONTENT_PHASE 阶段的。挂载的动作一般是在模块上下文调用的 postconfiguration 函数中。</p>
<p><strong>注意：有几个阶段是特例，它不调用挂载地任何的handler，也就是你就不用挂载到这几个阶段了：</strong></p>
<ul>
<li>NGX_HTTP_FIND_CONFIG_PHASE</li>
<li>NGX_HTTP_POST_ACCESS_PHASE</li>
<li>NGX_HTTP_POST_REWRITE_PHASE</li>
<li>NGX_HTTP_TRY_FILES_PHASE</li>
</ul>
<p>所以其实真正是有 7 个 phase 你可以去挂载 handler。</p>
<p>挂载的代码如下（摘自 hello module）:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">static</span> ngx_int_t</span><br><span class="line">ngx_http_hello_init(ngx_conf_t *cf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">ngx_http_handler_pt</span>        *h;</span><br><span class="line">    <span class="attribute">ngx_http_core_main_conf_t</span>  *cmcf;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">cmcf</span> = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">h</span> = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers);</span><br><span class="line">    <span class="attribute">if</span> (h == NULL) &#123;</span><br><span class="line">        <span class="attribute">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *h = ngx_http_hello_handler;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方式挂载的 handler 也被称为 <strong>content phase handlers</strong>。</p>
<h2 id="按需挂载"><a href="#按需挂载" class="headerlink" title="按需挂载"></a>按需挂载</h2><p>以这种方式挂载的 handler 也被称为 <strong>content handler</strong>。</p>
<p>当一个请求进来以后，Nginx 从 NGX_HTTP_POST_READ_PHASE 阶段开始依次执行每个阶段中所有 handler。执行到 NGX_HTTP_CONTENT_PHASE 阶段的时候，如果这个 location 有一个对应的 content handler 模块，那么就去执行这个 content handler 模块真正的处理函数。否则继续依次执行 NGX_HTTP_CONTENT_PHASE 阶段中所有 content phase handlers，直到某个函数处理返回 NGX_OK 或者 NGX_ERROR。</p>
<p>换句话说，当某个 location 处理到 NGX_HTTP_CONTENT_PHASE 阶段时，如果有 content handler 模块，那么 NGX_HTTP_CONTENT_PHASE 挂载的所有 content phase handlers 都不会被执行了。</p>
<p>但是使用这个方法挂载上去的 handler 有一个特点是必须在 NGX_HTTP_CONTENT_PHASE 阶段才能执行到。如果你想自己的 handler 在更早的阶段执行，那就不要使用这种挂载方式。</p>
<p>那么在什么情况会使用这种方式来挂载呢？一般情况下，某个模块对某个 location 进行了处理以后，发现符合自己处理的逻辑，而且也没有必要再调用 NGX_HTTP_CONTENT_PHASE 阶段的其它 handler 进行处理的时候，就动态挂载上这个 handler。</p>
<p>下面来看一下使用这种挂载方式的具体例子（摘自 Emiller’s Guide To Nginx Module Development）。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">static</span> char *</span><br><span class="line">ngx_http_circle_gif(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">ngx_http_core_loc_conf_t</span>  *clcf;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">clcf</span> = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);</span><br><span class="line">    clcf-&gt;handler = ngx_http_circle_gif_handler;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> NGX_CONF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Nginx-handler-的编写步骤"><a href="#Nginx-handler-的编写步骤" class="headerlink" title="Nginx handler 的编写步骤"></a>Nginx handler 的编写步骤</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="handler-的编写步骤"><a href="#handler-的编写步骤" class="headerlink" title="handler 的编写步骤"></a>handler 的编写步骤</h2><p>好，到了这里，让我们稍微整理一下思路，回顾一下实现一个 handler 的步骤:</p>
<ol>
<li>编写模块基本结构。包括模块的定义，模块上下文结构，模块的配置结构等。</li>
<li>实现 handler 的挂载函数。根据模块的需求选择正确的挂载方式。</li>
<li>编写 handler 处理函数。模块的功能主要通过这个函数来完成。</li>
</ol>
<p>看起来不是那么难，对吧？还是那句老话，世上无难事，只怕有心人! 现在我们来完整的分析前面提到的 hello handler module 示例的功能和代码。</p>
<h1 id="Nginx-示例-hello-handler-模块"><a href="#Nginx-示例-hello-handler-模块" class="headerlink" title="Nginx 示例: hello handler 模块"></a>Nginx 示例: hello handler 模块</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="示例-hello-handler-模块"><a href="#示例-hello-handler-模块" class="headerlink" title="示例: hello handler 模块"></a>示例: hello handler 模块</h2><p>在前面已经看到了这个 hello handler module 的部分重要的结构。该模块提供了 2 个配置指令，仅可以出现在 location 指令的作用域中。这两个指令是 hello_string, 该指令接受一个参数来设置显示的字符串。如果没有跟参数，那么就使用默认的字符串作为响应字符串。</p>
<p>另一个指令是 hello_counter，如果设置为 on，则会在响应的字符串后面追加 Visited Times:的字样，以统计请求的次数。</p>
<p>这里有两点注意一下：</p>
<ol>
<li>对于 flag 类型的配置指令，当值为 off 的时候，使用 ngx_conf_set_flag_slot 函数，会转化为 0，为on，则转化为非 0。</li>
<li>另外一个是，我提供了 merge_loc_conf 函数，但是却没有设置到模块的上下文定义中。这样有一个缺点，就是如果一个指令没有出现在配置文件中的时候，配置信息中的值，将永远会保持在 create_loc_conf 中的初始化的值。那如果，在类似 create_loc_conf 这样的函数中，对创建出来的配置信息的值，没有设置为合理的值的话，后面用户又没有配置，就会出现问题。</li>
</ol>
<p>下面来完整的给出 ngx_http_hello_module 模块的完整代码。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;ngx_config.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;ngx_core.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;ngx_http.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">typedef</span> struct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">ngx_str_t</span> hello_string;</span><br><span class="line">    <span class="attribute">ngx_int_t</span> hello_counter;</span><br><span class="line">&#125;ngx_http_hello_loc_conf_t;</span><br><span class="line"></span><br><span class="line"><span class="attribute">static</span> ngx_int_t ngx_http_hello_init(ngx_conf_t *cf);</span><br><span class="line"></span><br><span class="line"><span class="attribute">static</span> void *ngx_http_hello_create_loc_conf(ngx_conf_t *cf);</span><br><span class="line"></span><br><span class="line"><span class="attribute">static</span> char *ngx_http_hello_string(ngx_conf_t *cf, ngx_command_t *cmd,</span><br><span class="line">    void *conf);</span><br><span class="line"><span class="attribute">static</span> char *ngx_http_hello_counter(ngx_conf_t *cf, ngx_command_t *cmd,</span><br><span class="line">    void *conf);</span><br><span class="line"></span><br><span class="line"><span class="attribute">static</span> ngx_command_t ngx_http_hello_commands[] = &#123;</span><br><span class="line">   &#123; </span><br><span class="line">        ngx_string("hello_string"),</span><br><span class="line">        NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1,</span><br><span class="line">        ngx_http_hello_string,</span><br><span class="line">        NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">        offsetof(ngx_http_hello_loc_conf_t, hello_string),</span><br><span class="line">        <span class="attribute">NULL</span> &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; </span><br><span class="line">        ngx_string("hello_counter"),</span><br><span class="line">        NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,</span><br><span class="line">        ngx_http_hello_counter,</span><br><span class="line">        NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">        offsetof(ngx_http_hello_loc_conf_t, hello_counter),</span><br><span class="line">        <span class="attribute">NULL</span> &#125;,               </span><br><span class="line"></span><br><span class="line">    ngx_null_command</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"><span class="attribute">static</span> u_char ngx_hello_default_string[] = <span class="string">"Default String: Hello, world!"</span>;</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">static</span> int ngx_hello_visited_times = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="attribute">static</span> ngx_http_module_t ngx_http_hello_module_ctx = &#123;</span><br><span class="line">    NULL,                          /* preconfiguration */</span><br><span class="line">    ngx_http_hello_init,           /* postconfiguration */</span><br><span class="line"></span><br><span class="line">    NULL,                          /* create main configuration */</span><br><span class="line">    NULL,                          /* init main configuration */</span><br><span class="line"></span><br><span class="line">    NULL,                          /* create server configuration */</span><br><span class="line">    NULL,                          /* merge server configuration */</span><br><span class="line"></span><br><span class="line">    ngx_http_hello_create_loc_conf, /* create location configuration */</span><br><span class="line">    <span class="attribute">NULL</span>                            /* merge location configuration */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="attribute">ngx_module_t</span> ngx_http_hello_module = &#123;</span><br><span class="line">    NGX_MODULE_V1,</span><br><span class="line">    &amp;ngx_http_hello_module_ctx,    /* module context */</span><br><span class="line">    ngx_http_hello_commands,       /* module directives */</span><br><span class="line">    NGX_HTTP_MODULE,               /* module type */</span><br><span class="line">    NULL,                          /* init master */</span><br><span class="line">    NULL,                          /* init module */</span><br><span class="line">    NULL,                          /* init process */</span><br><span class="line">    NULL,                          /* init thread */</span><br><span class="line">    NULL,                          /* exit thread */</span><br><span class="line">    NULL,                          /* exit process */</span><br><span class="line">    NULL,                          /* exit master */</span><br><span class="line">    NGX_MODULE_V1_PADDING</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="attribute">static</span> ngx_int_t</span><br><span class="line">ngx_http_hello_handler(ngx_http_request_t *r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">ngx_int_t</span>    rc;</span><br><span class="line">    <span class="attribute">ngx_buf_t</span>   *b;</span><br><span class="line">    <span class="attribute">ngx_chain_t</span>  out;</span><br><span class="line">    ngx_http_hello_loc_conf_t* my_conf;</span><br><span class="line">    u_char ngx_hello_string[1024] = &#123;0&#125;;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span> content_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, 0, "ngx_http_hello_handler is called!");</span><br><span class="line"></span><br><span class="line">    <span class="attribute">my_conf</span> = ngx_http_get_module_loc_conf(r, ngx_http_hello_module);</span><br><span class="line">    <span class="attribute">if</span> (my_conf-&gt;hello_string.len == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, 0, "hello_string is empty!");</span><br><span class="line">        <span class="attribute">return</span> NGX_DECLINED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (my_conf-&gt;hello_counter == NGX_CONF_UNSET</span><br><span class="line">        || my_conf-&gt;hello_counter == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_sprintf(ngx_hello_string, "%s", my_conf-&gt;hello_string.data);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_sprintf(ngx_hello_string, "%s Visited Times:%d", my_conf-&gt;hello_string.data, </span><br><span class="line">            ++ngx_hello_visited_times);</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, 0, "hello_string:%s", ngx_hello_string);</span><br><span class="line">    <span class="attribute">content_length</span> = ngx_strlen(ngx_hello_string);</span><br><span class="line"></span><br><span class="line">    /* we response to 'GET' and 'HEAD' requests only */</span><br><span class="line">    <span class="attribute">if</span> (!(r-&gt;method &amp; (NGX_HTTP_GET|NGX_HTTP_HEAD))) &#123;</span><br><span class="line">        <span class="attribute">return</span> NGX_HTTP_NOT_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* discard request body, since we don't need it here */</span><br><span class="line">    <span class="attribute">rc</span> = ngx_http_discard_request_body(r);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (rc != NGX_OK) &#123;</span><br><span class="line">        <span class="attribute">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* set the 'Content-type' header */</span><br><span class="line">    /*</span><br><span class="line">     *r-&gt;headers_out.content_type.len = sizeof("text/html") - 1;</span><br><span class="line">     *r-&gt;headers_out.content_type.data = (u_char *)"text/html";</span><br><span class="line">             */</span><br><span class="line">    ngx_str_set(&amp;r-&gt;headers_out.content_type, "text/html");</span><br><span class="line"></span><br><span class="line">    /* send the header only, if the request type is http 'HEAD' */</span><br><span class="line">    <span class="attribute">if</span> (r-&gt;method == NGX_HTTP_HEAD) &#123;</span><br><span class="line">        r-&gt;headers_out.status = NGX_HTTP_OK;</span><br><span class="line">        r-&gt;headers_out.content_length_n = content_length;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">return</span> ngx_http_send_header(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* allocate a buffer for your response body */</span><br><span class="line">    <span class="attribute">b</span> = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t));</span><br><span class="line">    <span class="attribute">if</span> (b == NULL) &#123;</span><br><span class="line">        <span class="attribute">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* attach this buffer to the buffer chain */</span><br><span class="line">    out.buf = b;</span><br><span class="line">    out.next = NULL;</span><br><span class="line"></span><br><span class="line">    /* adjust the pointers of the buffer */</span><br><span class="line">    b-&gt;pos = ngx_hello_string;</span><br><span class="line">    b-&gt;last = ngx_hello_string + content_length;</span><br><span class="line">    b-&gt;memory = 1;    /* this buffer is in memory */</span><br><span class="line">    b-&gt;last_buf = 1;  /* this is the last buffer in the buffer chain */</span><br><span class="line"></span><br><span class="line">    /* set the status line */</span><br><span class="line">    r-&gt;headers_out.status = NGX_HTTP_OK;</span><br><span class="line">    r-&gt;headers_out.content_length_n = content_length;</span><br><span class="line"></span><br><span class="line">    /* send the headers of your response */</span><br><span class="line">    <span class="attribute">rc</span> = ngx_http_send_header(r);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) &#123;</span><br><span class="line">        <span class="attribute">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* send the buffer chain of your response */</span><br><span class="line">    <span class="attribute">return</span> ngx_http_output_filter(r, &amp;out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">static</span> void *ngx_http_hello_create_loc_conf(ngx_conf_t *cf)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_hello_loc_conf_t* local_conf = NULL;</span><br><span class="line">    <span class="attribute">local_conf</span> = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_hello_loc_conf_t));</span><br><span class="line">    <span class="attribute">if</span> (local_conf == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_str_null(&amp;local_conf-&gt;hello_string);</span><br><span class="line">    local_conf-&gt;hello_counter = NGX_CONF_UNSET;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> local_conf;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"><span class="attribute">static</span> char *ngx_http_hello_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_hello_loc_conf_t* prev = parent;</span><br><span class="line">    ngx_http_hello_loc_conf_t* conf = child;</span><br><span class="line"></span><br><span class="line">    ngx_conf_merge_str_value(conf-&gt;hello_string, prev-&gt;hello_string, ngx_hello_default_string);</span><br><span class="line">    ngx_conf_merge_value(conf-&gt;hello_counter, prev-&gt;hello_counter, 0);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> NGX_CONF_OK;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line"><span class="attribute">static</span> char *</span><br><span class="line">ngx_http_hello_string(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ngx_http_hello_loc_conf_t* local_conf;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">local_conf</span> = conf;</span><br><span class="line">    char* rv = ngx_conf_set_str_slot(cf, cmd, conf);</span><br><span class="line"></span><br><span class="line">    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "hello_string:%s", local_conf-&gt;hello_string.data);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">static</span> char *ngx_http_hello_counter(ngx_conf_t *cf, ngx_command_t *cmd,</span><br><span class="line">    void *conf)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_hello_loc_conf_t* local_conf;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">local_conf</span> = conf;</span><br><span class="line"></span><br><span class="line">    char* rv = NULL;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">rv</span> = ngx_conf_set_flag_slot(cf, cmd, conf);</span><br><span class="line"></span><br><span class="line">    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "hello_counter:%d", local_conf-&gt;hello_counter);</span><br><span class="line">    <span class="attribute">return</span> rv;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">static</span> ngx_int_t</span><br><span class="line">ngx_http_hello_init(ngx_conf_t *cf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">ngx_http_handler_pt</span>        *h;</span><br><span class="line">    <span class="attribute">ngx_http_core_main_conf_t</span>  *cmcf;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">cmcf</span> = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">h</span> = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers);</span><br><span class="line">    <span class="attribute">if</span> (h == NULL) &#123;</span><br><span class="line">        <span class="attribute">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *h = ngx_http_hello_handler;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面一些介绍，我相信大家都能对整个示例模块有一个比较好的理解。唯一可能感觉有些理解困难的地方在于ngx_http_hello_handler 函数里面产生和设置输出。但其实大家在本书的前面的相关章节都可以看到对 ngx_buf_t 和 request 等相关数据结构的说明。如果仔细看了这些地方的说明的话，应该对这里代码的实现就比较容易理解了。因此，这里不再赘述解释。</p>
<h1 id="Nginx-handler-模块的编译和使用"><a href="#Nginx-handler-模块的编译和使用" class="headerlink" title="Nginx handler 模块的编译和使用"></a>Nginx handler 模块的编译和使用</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="handler-模块的编译和使用"><a href="#handler-模块的编译和使用" class="headerlink" title="handler 模块的编译和使用"></a>handler 模块的编译和使用</h2><p>模块的功能开发完了之后，模块的使用还需要编译才能够执行，下面我们来看下模块的编译和使用。</p>
<h2 id="config-文件的编写"><a href="#config-文件的编写" class="headerlink" title="config 文件的编写"></a>config 文件的编写</h2><p>对于开发一个模块，我们是需要把这个模块的 C 代码组织到一个目录里，同时需要编写一个 config 文件。这个 config 文件的内容就是告诉 Nginx 的编译脚本，该如何进行编译。我们来看一下 hello handler module 的 config 文件的内容，然后再做解释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_addon_name=ngx_http_hello_module</span><br><span class="line">HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_hello_module&quot;</span><br><span class="line">NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_hello_module.c&quot;</span><br></pre></td></tr></table></figure>
<p>其实文件很简单，几乎不需要做什么解释。大家一看都懂了。唯一需要说明的是，如果这个模块的实现有多个源文件，那么都在 NGX_ADDON_SRCS 这个变量里，依次写进去就可以。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>对于模块的编译，Nginx 并不像 apache 一样，提供了单独的编译工具，可以在没有 apache 源代码的情况下来单独编译一个模块的代码。Nginx 必须去到 Nginx 的源代码目录里，通过 configure 指令的参数，来进行编译。下面看一下 hello module 的 configure 指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx-1.3.1 --add-module=/home/jizhao/open_source/book_module</span><br></pre></td></tr></table></figure>
<p>我写的这个示例模块的代码和 config 文件都放在<code>/home/jizhao/open_source/book_module</code>这个目录下。所以一切都很明了，也没什么好说的了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用一个模块需要根据这个模块定义的配置指令来做。比如我们这个简单的 hello handler module 的使用就很简单。在我的测试服务器的配置文件里，就是在 http 里面的默认的 server 里面加入如下的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">        hello_string jizhao;</span><br><span class="line">        hello_counter on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们访问这个地址的时候, <code>lynx http://127.0.0.1/test</code> 的时候，就可以看到返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jizhao Visited Times:1</span><br></pre></td></tr></table></figure>
<p>当然你访问多次，这个次数是会增加的。</p>
<h1 id="Nginx-更多-handler-模块示例分析"><a href="#Nginx-更多-handler-模块示例分析" class="headerlink" title="Nginx 更多 handler 模块示例分析"></a>Nginx 更多 handler 模块示例分析</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="更多-handler-模块示例分析"><a href="#更多-handler-模块示例分析" class="headerlink" title="更多 handler 模块示例分析"></a>更多 handler 模块示例分析</h2><h2 id="http-access-module"><a href="#http-access-module" class="headerlink" title="http access module"></a>http access module</h2><p>该模块的代码位于<code>src/http/modules/ngx_http_access_module.c</code>中。该模块的作用是提供对于特定 host 的客户端的访问控制。可以限定特定 host 的客户端对于服务端全部，或者某个 server，或者是某个 location 的访问。</p>
<p>该模块的实现非常简单，总共也就只有几个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static ngx_int_t ngx_http_access_handler(ngx_http_request_t *r);</span><br><span class="line">static ngx_int_t ngx_http_access_inet(ngx_http_request_t *r,</span><br><span class="line">    ngx_http_access_loc_conf_t *alcf, in_addr_t addr);</span><br><span class="line">#if (NGX_HAVE_INET6)</span><br><span class="line">static ngx_int_t ngx_http_access_inet6(ngx_http_request_t *r,</span><br><span class="line">    ngx_http_access_loc_conf_t *alcf, u_char *p);</span><br><span class="line">#endif</span><br><span class="line">static ngx_int_t ngx_http_access_found(ngx_http_request_t *r, ngx_uint_t deny);</span><br><span class="line">static char *ngx_http_access_rule(ngx_conf_t *cf, ngx_command_t *cmd,</span><br><span class="line">    void *conf);</span><br><span class="line">static void *ngx_http_access_create_loc_conf(ngx_conf_t *cf);</span><br><span class="line">static char *ngx_http_access_merge_loc_conf(ngx_conf_t *cf,</span><br><span class="line">    void *parent, void *child);</span><br><span class="line">static ngx_int_t ngx_http_access_init(ngx_conf_t *cf);</span><br></pre></td></tr></table></figure>
<p>对于与配置相关的几个函数都不需要做解释了，需要提一下的是函数 ngx_http_access_init，该函数在实现上把本模块挂载到了 NGX_HTTP_ACCESS_PHASE 阶段的 handler 上，从而使自己的被调用时机发生在了 NGX_HTTP_CONTENT_PHASE 等阶段前。因为进行客户端地址的限制检查，根本不需要等到这么后面。</p>
<p>另外看一下这个模块的主处理函数 ngx_http_access_handler。这个函数的逻辑也非常简单，主要是根据客户端地址的类型，来分别选择 ipv4 类型的处理函数 ngx_http_access_inet 还是 ipv6 类型的处理函数 ngx_http_access_inet6。</p>
<p>而这个两个处理函数内部也非常简单，就是循环检查每个规则，检查是否有匹配的规则，如果有就返回匹配的结果，如果都没有匹配，就默认拒绝。</p>
<h2 id="http-static-module"><a href="#http-static-module" class="headerlink" title="http static module"></a>http static module</h2><p>从某种程度上来说，此模块可以算的上是“最正宗的”，“最古老”的 content handler。因为本模块的作用就是读取磁盘上的静态文件，并把文件内容作为产生的输出。在Web技术发展的早期，只有静态页面，没有服务端脚本来动态生成 HTML 的时候。恐怕开发个 Web 服务器的时候，第一个要开发就是这样一个 content handler。</p>
<p>http static module 的代码位于<code>src/http/modules/ngx_http_static_module.c</code>中，总共只有两百多行近三百行。可以说是非常短小。</p>
<p>我们首先来看一下该模块的模块上下文的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_module_t  ngx_http_static_module_ctx = &#123;</span><br><span class="line">    NULL,                                  /* preconfiguration */</span><br><span class="line">    ngx_http_static_init,                  /* postconfiguration */</span><br><span class="line"></span><br><span class="line">    NULL,                                  /* create main configuration */</span><br><span class="line">    NULL,                                  /* init main configuration */</span><br><span class="line"></span><br><span class="line">    NULL,                                  /* create server configuration */</span><br><span class="line">    NULL,                                  /* merge server configuration */</span><br><span class="line"></span><br><span class="line">    NULL,                                  /* create location configuration */</span><br><span class="line">    NULL                                   /* merge location configuration */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>是非常的简洁吧，连任何与配置相关的函数都没有。对了，因为该模块没有提供任何配置指令。大家想想也就知道了，这个模块做的事情实在是太简单了，也确实没什么好配置的。唯一需要调用的函数是一个 ngx_http_static_init 函数。好了，来看一下这个函数都干了写什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static ngx_int_t</span><br><span class="line">ngx_http_static_init(ngx_conf_t *cf)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_handler_pt        *h;</span><br><span class="line">    ngx_http_core_main_conf_t  *cmcf;</span><br><span class="line"></span><br><span class="line">    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);</span><br><span class="line"></span><br><span class="line">    h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers);</span><br><span class="line">    if (h == NULL) &#123;</span><br><span class="line">        return NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *h = ngx_http_static_handler;</span><br><span class="line"></span><br><span class="line">    return NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅是挂载这个 handler 到 NGX_HTTP_CONTENT_PHASE 处理阶段。简单吧？</p>
<p>下面我们就看一下这个模块最核心的处理逻辑所在的 ngx_http_static_handler 函数。该函数大概占了这个模块代码量的百分之八九十。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line">static ngx_int_t</span><br><span class="line">ngx_http_static_handler(ngx_http_request_t *r)</span><br><span class="line">&#123;</span><br><span class="line">    u_char                    *last, *location;</span><br><span class="line">    size_t                     root, len;</span><br><span class="line">    ngx_str_t                  path;</span><br><span class="line">    ngx_int_t                  rc;</span><br><span class="line">    ngx_uint_t                 level;</span><br><span class="line">    ngx_log_t                 *log;</span><br><span class="line">    ngx_buf_t                 *b;</span><br><span class="line">    ngx_chain_t                out;</span><br><span class="line">    ngx_open_file_info_t       of;</span><br><span class="line">    ngx_http_core_loc_conf_t  *clcf;</span><br><span class="line"></span><br><span class="line">    if (!(r-&gt;method &amp; (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) &#123;</span><br><span class="line">        return NGX_HTTP_NOT_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r-&gt;uri.data[r-&gt;uri.len - 1] == &apos;/&apos;) &#123;</span><br><span class="line">        return NGX_DECLINED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log = r-&gt;connection-&gt;log;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * ngx_http_map_uri_to_path() allocates memory for terminating &apos;\0&apos;</span><br><span class="line">     * so we do not need to reserve memory for &apos;/&apos; for possible redirect</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    last = ngx_http_map_uri_to_path(r, &amp;path, &amp;root, 0);</span><br><span class="line">    if (last == NULL) &#123;</span><br><span class="line">        return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.len = last - path.data;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0,</span><br><span class="line">                   &quot;http filename: \&quot;%s\&quot;&quot;, path.data);</span><br><span class="line"></span><br><span class="line">    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);</span><br><span class="line"></span><br><span class="line">    ngx_memzero(&amp;of, sizeof(ngx_open_file_info_t));</span><br><span class="line"></span><br><span class="line">    of.read_ahead = clcf-&gt;read_ahead;</span><br><span class="line">    of.directio = clcf-&gt;directio;</span><br><span class="line">    of.valid = clcf-&gt;open_file_cache_valid;</span><br><span class="line">    of.min_uses = clcf-&gt;open_file_cache_min_uses;</span><br><span class="line">    of.errors = clcf-&gt;open_file_cache_errors;</span><br><span class="line">    of.events = clcf-&gt;open_file_cache_events;</span><br><span class="line"></span><br><span class="line">    if (ngx_http_set_disable_symlinks(r, clcf, &amp;path, &amp;of) != NGX_OK) &#123;</span><br><span class="line">        return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_open_cached_file(clcf-&gt;open_file_cache, &amp;path, &amp;of, r-&gt;pool)</span><br><span class="line">        != NGX_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        switch (of.err) &#123;</span><br><span class="line"></span><br><span class="line">        case 0:</span><br><span class="line">            return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line"></span><br><span class="line">        case NGX_ENOENT:</span><br><span class="line">        case NGX_ENOTDIR:</span><br><span class="line">        case NGX_ENAMETOOLONG:</span><br><span class="line"></span><br><span class="line">            level = NGX_LOG_ERR;</span><br><span class="line">            rc = NGX_HTTP_NOT_FOUND;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case NGX_EACCES:</span><br><span class="line">#if (NGX_HAVE_OPENAT)</span><br><span class="line">        case NGX_EMLINK:</span><br><span class="line">        case NGX_ELOOP:</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">            level = NGX_LOG_ERR;</span><br><span class="line">            rc = NGX_HTTP_FORBIDDEN;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line"></span><br><span class="line">            level = NGX_LOG_CRIT;</span><br><span class="line">            rc = NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (rc != NGX_HTTP_NOT_FOUND || clcf-&gt;log_not_found) &#123;</span><br><span class="line">            ngx_log_error(level, log, of.err,</span><br><span class="line">                          &quot;%s \&quot;%s\&quot; failed&quot;, of.failed, path.data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r-&gt;root_tested = !r-&gt;error_page;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0, &quot;http static fd: %d&quot;, of.fd);</span><br><span class="line"></span><br><span class="line">    if (of.is_dir) &#123;</span><br><span class="line"></span><br><span class="line">        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0, &quot;http dir&quot;);</span><br><span class="line"></span><br><span class="line">        ngx_http_clear_location(r);</span><br><span class="line"></span><br><span class="line">        r-&gt;headers_out.location = ngx_palloc(r-&gt;pool, sizeof(ngx_table_elt_t));</span><br><span class="line">        if (r-&gt;headers_out.location == NULL) &#123;</span><br><span class="line">            return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len = r-&gt;uri.len + 1;</span><br><span class="line"></span><br><span class="line">        if (!clcf-&gt;alias &amp;&amp; clcf-&gt;root_lengths == NULL &amp;&amp; r-&gt;args.len == 0) &#123;</span><br><span class="line">            location = path.data + clcf-&gt;root.len;</span><br><span class="line"></span><br><span class="line">            *last = &apos;/&apos;;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (r-&gt;args.len) &#123;</span><br><span class="line">                len += r-&gt;args.len + 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            location = ngx_pnalloc(r-&gt;pool, len);</span><br><span class="line">            if (location == NULL) &#123;</span><br><span class="line">                return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            last = ngx_copy(location, r-&gt;uri.data, r-&gt;uri.len);</span><br><span class="line"></span><br><span class="line">            *last = &apos;/&apos;;</span><br><span class="line"></span><br><span class="line">            if (r-&gt;args.len) &#123;</span><br><span class="line">                *++last = &apos;?&apos;;</span><br><span class="line">                ngx_memcpy(++last, r-&gt;args.data, r-&gt;args.len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * we do not need to set the r-&gt;headers_out.location-&gt;hash and</span><br><span class="line">         * r-&gt;headers_out.location-&gt;key fields</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        r-&gt;headers_out.location-&gt;value.len = len;</span><br><span class="line">        r-&gt;headers_out.location-&gt;value.data = location;</span><br><span class="line"></span><br><span class="line">        return NGX_HTTP_MOVED_PERMANENTLY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if !(NGX_WIN32) /* the not regular files are probably Unix specific */</span><br><span class="line"></span><br><span class="line">    if (!of.is_file) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_CRIT, log, 0,</span><br><span class="line">                      &quot;\&quot;%s\&quot; is not a regular file&quot;, path.data);</span><br><span class="line"></span><br><span class="line">        return NGX_HTTP_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    if (r-&gt;method &amp; NGX_HTTP_POST) &#123;</span><br><span class="line">        return NGX_HTTP_NOT_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = ngx_http_discard_request_body(r);</span><br><span class="line"></span><br><span class="line">    if (rc != NGX_OK) &#123;</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log-&gt;action = &quot;sending response to client&quot;;</span><br><span class="line"></span><br><span class="line">    r-&gt;headers_out.status = NGX_HTTP_OK;</span><br><span class="line">    r-&gt;headers_out.content_length_n = of.size;</span><br><span class="line">    r-&gt;headers_out.last_modified_time = of.mtime;</span><br><span class="line"></span><br><span class="line">    if (ngx_http_set_content_type(r) != NGX_OK) &#123;</span><br><span class="line">        return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r != r-&gt;main &amp;&amp; of.size == 0) &#123;</span><br><span class="line">        return ngx_http_send_header(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r-&gt;allow_ranges = 1;</span><br><span class="line"></span><br><span class="line">    /* we need to allocate all before the header would be sent */</span><br><span class="line"></span><br><span class="line">    b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t));</span><br><span class="line">    if (b == NULL) &#123;</span><br><span class="line">        return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b-&gt;file = ngx_pcalloc(r-&gt;pool, sizeof(ngx_file_t));</span><br><span class="line">    if (b-&gt;file == NULL) &#123;</span><br><span class="line">        return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = ngx_http_send_header(r);</span><br><span class="line"></span><br><span class="line">    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) &#123;</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b-&gt;file_pos = 0;</span><br><span class="line">    b-&gt;file_last = of.size;</span><br><span class="line"></span><br><span class="line">    b-&gt;in_file = b-&gt;file_last ? 1: 0;</span><br><span class="line">    b-&gt;last_buf = (r == r-&gt;main) ? 1: 0;</span><br><span class="line">    b-&gt;last_in_chain = 1;</span><br><span class="line"></span><br><span class="line">    b-&gt;file-&gt;fd = of.fd;</span><br><span class="line">    b-&gt;file-&gt;name = path;</span><br><span class="line">    b-&gt;file-&gt;log = log;</span><br><span class="line">    b-&gt;file-&gt;directio = of.is_directio;</span><br><span class="line"></span><br><span class="line">    out.buf = b;</span><br><span class="line">    out.next = NULL;</span><br><span class="line"></span><br><span class="line">    return ngx_http_output_filter(r, &amp;out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是检查客户端的 http 请求类型（r-&gt;method），如果请求类型为<code>NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST</code>，则继续进行处理，否则一律返回 NGX_HTTP_NOT_ALLOWED 从而拒绝客户端的发起的请求。</p>
<p>其次是检查请求的 url 的结尾字符是不是斜杠<code>/</code>，如果是说明请求的不是一个文件，给后续的 handler 去处理，比如后续的 ngx_http_autoindex_handler（如果是请求的是一个目录下面，可以列出这个目录的文件），或者是 ngx_http_index_handler（如果请求的路径下面有个默认的 index 文件，直接返回 index 文件的内容）。</p>
<p>然后接下来调用了一个 ngx_http_map_uri_to_path 函数，该函数的作用是把请求的 http 协议的路径转化成一个文件系统的路径。</p>
<p>然后根据转化出来的具体路径，去打开文件，打开文件的时候做了 2 种检查，一种是，如果请求的文件是个 symbol link，根据配置，是否允许符号链接，不允许返回错误。还有一个检查是，如果请求的是一个名称，是一个目录的名字，也返回错误。如果都没有错误，就读取文件，返回内容。其实说返回内容可能不是特别准确，比较准确的说法是，把产生的内容传递给后续的 filter 去处理。</p>
<h2 id="http-log-module"><a href="#http-log-module" class="headerlink" title="http log module"></a>http log module</h2><p>该模块提供了对于每一个 http 请求进行记录的功能，也就是我们见到的 access.log。当然这个模块对于 log 提供了一些配置指令，使得可以比较方便的定制 access.log。</p>
<p>这个模块的代码位于<code>src/http/modules/ngx_http_log_module.c</code>，虽然这个模块的代码有接近 1400 行，但是主要的逻辑在于对日志本身格式啊，等细节的处理。我们在这里进行分析主要是关注，如何编写一个 log handler 的问题。</p>
<p>由于 log handler 的时候，拿到的参数也是 request 这个东西，那么也就意味着我们如果需要，可以好好研究下这个结构，把我们需要的所有信息都记录下来。</p>
<p>对于 log handler，有一点特别需要注意的就是，log handler 是无论如何都会被调用的，就是只要服务端接受到了一个客户端的请求，也就是产生了一个 request 对象，那么这些个 log handler 的处理函数都会被调用的，就是在释放 request 的时候被调用的（ngx_http_free_request函数）。</p>
<p>那么当然绝对不能忘记的就是 log handler 最好，也是建议被挂载在 NGX_HTTP_LOG_PHASE 阶段。因为挂载在其他阶段，有可能在某些情况下被跳过，而没有执行到，导致你的 log 模块记录的信息不全。</p>
<p>还有一点要说明的是，由于 Nginx 是允许在某个阶段有多个 handler 模块存在的，根据其处理结果，确定是否要调用下一个 handler。但是对于挂载在 NGX_HTTP_LOG_PHASE 阶段的 handler，则根本不关注这里 handler 的具体处理函数的返回值，所有的都被调用。如下，位于<code>src/http/ngx_http_request.c</code>中的 ngx_http_log_request 函数。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">static</span> void</span><br><span class="line">ngx_http_log_request(ngx_http_request_t *r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">ngx_uint_t</span>                  i, n;</span><br><span class="line">    <span class="attribute">ngx_http_handler_pt</span>        *log_handler;</span><br><span class="line">    <span class="attribute">ngx_http_core_main_conf_t</span>  *cmcf;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">cmcf</span> = ngx_http_get_module_main_conf(r, ngx_http_core_module);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_handler</span> = cmcf-&gt;phases[NGX_HTTP_LOG_PHASE].handlers.elts;</span><br><span class="line">    <span class="attribute">n</span> = cmcf-&gt;phases[NGX_HTTP_LOG_PHASE].handlers.nelts;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        log_handler[i](r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Nginx-过滤模块简介"><a href="#Nginx-过滤模块简介" class="headerlink" title="Nginx 过滤模块简介"></a>Nginx 过滤模块简介</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="过滤模块简介"><a href="#过滤模块简介" class="headerlink" title="过滤模块简介"></a>过滤模块简介</h2><h2 id="执行时间和内容"><a href="#执行时间和内容" class="headerlink" title="执行时间和内容"></a>执行时间和内容</h2><p>过滤（filter）模块是过滤响应头和内容的模块，可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。它的处理过程分为两个阶段，过滤 HTTP 回复的头部和主体，在这两个阶段可以分别对头部和主体进行修改。</p>
<p>在代码中有类似的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_top_header_filter(r);</span><br><span class="line">ngx_http_top_body_filter(r, in);</span><br></pre></td></tr></table></figure>
<p>就是分别对头部和主体进行过滤的函数。所有模块的响应内容要返回给客户端，都必须调用这两个接口。</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>过滤模块的调用是有顺序的，它的顺序在编译的时候就决定了。控制编译的脚本位于 auto/modules 中，当你编译完 Nginx 以后，可以在 objs 目录下面看到一个 ngx_modules.c 的文件。打开这个文件，有类似的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ngx_module_t *ngx_modules[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    &amp;ngx_http_write_filter_module,</span><br><span class="line">    &amp;ngx_http_header_filter_module,</span><br><span class="line">    &amp;ngx_http_chunked_filter_module,</span><br><span class="line">    &amp;ngx_http_range_header_filter_module,</span><br><span class="line">    &amp;ngx_http_gzip_filter_module,</span><br><span class="line">    &amp;ngx_http_postpone_filter_module,</span><br><span class="line">    &amp;ngx_http_ssi_filter_module,</span><br><span class="line">    &amp;ngx_http_charset_filter_module,</span><br><span class="line">    &amp;ngx_http_userid_filter_module,</span><br><span class="line">    &amp;ngx_http_headers_filter_module,</span><br><span class="line">    &amp;ngx_http_copy_filter_module,</span><br><span class="line">    &amp;ngx_http_range_body_filter_module,</span><br><span class="line">    &amp;ngx_http_not_modified_filter_module,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从 write_filter 到 not_modified_filter，模块的执行顺序是反向的。也就是说最早执行的是 not_modified_filter，然后各个模块依次执行。一般情况下，第三方过滤模块的 config 文件会将模块名追加到变量 HTTP_AUX_FILTER_MODULES 中，此时该模块只能加入到 copy_filter 和 headers_filter 模块之间执行。</p>
<p>Nginx 执行的时候是怎么按照次序依次来执行各个过滤模块呢？它采用了一种很隐晦的方法，即通过局部的全局变量。比如，在每个 filter 模块，很可能看到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;</span><br><span class="line">static ngx_http_output_body_filter_pt    ngx_http_next_body_filter;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ngx_http_next_header_filter = ngx_http_top_header_filter;</span><br><span class="line">ngx_http_top_header_filter = ngx_http_example_header_filter;</span><br><span class="line"></span><br><span class="line">ngx_http_next_body_filter = ngx_http_top_body_filter;</span><br><span class="line">ngx_http_top_body_filter = ngx_http_example_body_filter;</span><br></pre></td></tr></table></figure>
<p>ngx_http_top_header_filter 是一个全局变量。当编译进一个 filter 模块的时候，就被赋值为当前 filter 模块的处理函数。而 ngx_http_next_header_filter 是一个局部全局变量，它保存了编译前上一个 filter 模块的处理函数。所以整体看来，就像用全局变量组成的一条单向链表。</p>
<p>每个模块想执行下一个过滤函数，只要调用一下 ngx_http_next_header_filter 这个局部变量。而整个过滤模块链的入口，需要调用 ngx_http_top_header_filter 这个全局变量。ngx_http_top_body_filter 的行为与 header fitler 类似。</p>
<p>响应头和响应体过滤函数的执行顺序如下所示：</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-4-1.png" alt="img"></p>
<p>这图只表示了 head_filter 和 body_filter 之间的执行顺序，在 header_filter 和 body_filter 处理函数之间，在 body_filter 处理函数之间，可能还有其他执行代码。</p>
<h2 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h2><p>Nginx 可以方便的加入第三方的过滤模块。在过滤模块的目录里，首先需要加入 config 文件，文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_addon_name=ngx_http_example_filter_module</span><br><span class="line">HTTP_AUX_FILTER_MODULES=&quot;$HTTP_AUX_FILTER_MODULES ngx_http_example_filter_module&quot;</span><br><span class="line">NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_example_filter_module.c&quot;</span><br></pre></td></tr></table></figure>
<p>说明把这个名为 ngx_http_example_filter_module 的过滤模块加入，ngx_http_example_filter_module.c 是该模块的源代码。</p>
<blockquote>
<p>注意 HTTP_AUX_FILTER_MODULES 这个变量与一般的内容处理模块不同。</p>
</blockquote>
<h1 id="Nginx-过滤模块的分析"><a href="#Nginx-过滤模块的分析" class="headerlink" title="Nginx 过滤模块的分析"></a>Nginx 过滤模块的分析</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="过滤模块的分析"><a href="#过滤模块的分析" class="headerlink" title="过滤模块的分析"></a>过滤模块的分析</h2><h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><p>ngx_chain_t 结构非常简单，是一个单向链表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ngx_chain_s ngx_chain_t;</span><br><span class="line"></span><br><span class="line">struct ngx_chain_s &#123;</span><br><span class="line">    ngx_buf_t    *buf;</span><br><span class="line">    ngx_chain_t  *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在过滤模块中，所有输出的内容都是通过一条单向链表所组成。这种单向链表的设计，正好应和了 Nginx 流式的输出模式。每次 Nginx 都是读到一部分的内容，就放到链表，然后输出出去。这种设计的好处是简单，非阻塞，但是相应的问题就是跨链表的内容操作非常麻烦，如果需要跨链表，很多时候都只能缓存链表的内容。</p>
<p>单链表负载的就是 ngx_buf_t，这个结构体使用非常广泛，先让我们看下该结构体的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">struct ngx_buf_s &#123;</span><br><span class="line">    u_char          *pos;       /* 当前buffer真实内容的起始位置 */</span><br><span class="line">    u_char          *last;      /* 当前buffer真实内容的结束位置 */</span><br><span class="line">    off_t            file_pos;  /* 在文件中真实内容的起始位置   */</span><br><span class="line">    off_t            file_last; /* 在文件中真实内容的结束位置   */</span><br><span class="line"></span><br><span class="line">    u_char          *start;    /* buffer内存的开始分配的位置 */</span><br><span class="line">    u_char          *end;      /* buffer内存的结束分配的位置 */</span><br><span class="line">    ngx_buf_tag_t    tag;      /* buffer属于哪个模块的标志 */</span><br><span class="line">    ngx_file_t      *file;     /* buffer所引用的文件 */</span><br><span class="line"></span><br><span class="line">    /* 用来引用替换过后的buffer，以便当所有buffer输出以后，</span><br><span class="line">     * 这个影子buffer可以被释放。</span><br><span class="line">     */</span><br><span class="line">    ngx_buf_t       *shadow; </span><br><span class="line"></span><br><span class="line">    /* the buf&apos;s content could be changed */</span><br><span class="line">    unsigned         temporary:1;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * the buf&apos;s content is in a memory cache or in a read only memory</span><br><span class="line">     * and must not be changed</span><br><span class="line">     */</span><br><span class="line">    unsigned         memory:1;</span><br><span class="line"></span><br><span class="line">    /* the buf&apos;s content is mmap()ed and must not be changed */</span><br><span class="line">    unsigned         mmap:1;</span><br><span class="line"></span><br><span class="line">    unsigned         recycled:1; /* 内存可以被输出并回收 */</span><br><span class="line">    unsigned         in_file:1;  /* buffer的内容在文件中 */</span><br><span class="line">    /* 马上全部输出buffer的内容, gzip模块里面用得比较多 */</span><br><span class="line">    unsigned         flush:1;</span><br><span class="line">    /* 基本上是一段输出链的最后一个buffer带的标志，标示可以输出，</span><br><span class="line">     * 有些零长度的buffer也可以置该标志</span><br><span class="line">     */</span><br><span class="line">    unsigned         sync:1;</span><br><span class="line">    /* 所有请求里面最后一块buffer，包含子请求 */</span><br><span class="line">    unsigned         last_buf:1;</span><br><span class="line">    /* 当前请求输出链的最后一块buffer         */</span><br><span class="line">    unsigned         last_in_chain:1;</span><br><span class="line">    /* shadow链里面的最后buffer，可以释放buffer了 */</span><br><span class="line">    unsigned         last_shadow:1;</span><br><span class="line">    /* 是否是暂存文件 */</span><br><span class="line">    unsigned         temp_file:1;</span><br><span class="line"></span><br><span class="line">    /* 统计用，表示使用次数 */</span><br><span class="line">    /* STUB */ int   num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一般 buffer 结构体可以表示一块内存，内存的起始和结束地址分别用 start 和 end 表示，pos 和 last 表示实际的内容。如果内容已经处理过了，pos 的位置就可以往后移动。如果读取到新的内容，last 的位置就会往后移动。所以 buffer 可以在多次调用过程中使用。如果 last 等于 end，就说明这块内存已经用完了。如果 pos 等于 last，说明内存已经处理完了。下面是一个简单的示意图，说明 buffer 中指针的用法：</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-4-2.png" alt="img"></p>
<h2 id="响应头过滤函数"><a href="#响应头过滤函数" class="headerlink" title="响应头过滤函数"></a>响应头过滤函数</h2><p>响应头过滤函数主要的用处就是处理 HTTP 响应的头，可以根据实际情况对于响应头进行修改或者添加删除。响应头过滤函数先于响应体过滤函数，而且只调用一次，所以一般可作过滤模块的初始化工作。</p>
<p>响应头过滤函数的入口只有一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ngx_int_t</span><br><span class="line">ngx_http_send_header(ngx_http_request_t *r)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return ngx_http_top_header_filter(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数向客户端发送回复的时候调用，然后按前一节所述的执行顺序。该函数的返回值一般是 NGX_OK，NGX_ERROR 和 NGX_AGAIN，分别表示处理成功，失败和未完成。</p>
<p>你可以把 HTTP 响应头的存储方式想象成一个 hash 表，在 Nginx 内部可以很方便地查找和修改各个响应头部，ngx_http_header_filter_module 过滤模块把所有的 HTTP 头组合成一个完整的 buffer，最终 ngx_http_write_filter_module 过滤模块把 buffer 输出。</p>
<p>按照前一节过滤模块的顺序，依次讲解如下：</p>
<table>
<thead>
<tr>
<th>filter module</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ngx_http_not_modified_filter_module</td>
<td>默认打开，如果请求的 if-modified-since 等于回复的 last-modified 间值，说明回复没有变化，清空所有回复的内容，返回 304。</td>
</tr>
<tr>
<td>ngx_http_range_body_filter_module</td>
<td>默认打开，只是响应体过滤函数，支持 range 功能，如果请求包含range请求，那就只发送range请求的一段内容。</td>
</tr>
<tr>
<td>ngx_http_copy_filter_module</td>
<td>始终打开，只是响应体过滤函数， 主要工作是把文件中内容读到内存中，以便进行处理。</td>
</tr>
<tr>
<td>ngx_http_headers_filter_module</td>
<td>始终打开，可以设置 expire 和 Cache-control 头，可以添加任意名称的头</td>
</tr>
<tr>
<td>ngx_http_userid_filter_module</td>
<td>默认关闭，可以添加统计用的识别用户的 cookie。</td>
</tr>
<tr>
<td>ngx_http_charset_filter_module</td>
<td>默认关闭，可以添加 charset，也可以将内容从一种字符集转换到另外一种字符集，不支持多字节字符集。</td>
</tr>
<tr>
<td>ngx_http_ssi_filter_module</td>
<td>默认关闭，过滤 SSI 请求，可以发起子请求，去获取include进来的文件</td>
</tr>
<tr>
<td>ngx_http_postpone_filter_module</td>
<td>始终打开，用来将子请求和主请求的输出链合并</td>
</tr>
<tr>
<td>ngx_http_gzip_filter_module</td>
<td>默认关闭，支持流式的压缩内容</td>
</tr>
<tr>
<td>ngx_http_range_header_filter_module</td>
<td>默认打开，只是响应头过滤函数，用来解析range头，并产生range响应的头。</td>
</tr>
<tr>
<td>ngx_http_chunked_filter_module</td>
<td>默认打开，对于 HTTP/1.1 和缺少 content-length 的回复自动打开。</td>
</tr>
<tr>
<td>ngx_http_header_filter_module</td>
<td>始终打开，用来将所有 header 组成一个完整的 HTTP 头。</td>
</tr>
<tr>
<td>ngx_http_write_filter_module</td>
<td>始终打开，将输出链拷贝到 r-&gt;out中，然后输出内容。</td>
</tr>
</tbody>
</table>
<h2 id="响应体过滤函数"><a href="#响应体过滤函数" class="headerlink" title="响应体过滤函数"></a>响应体过滤函数</h2><p>响应体过滤函数是过滤响应主体的函数。ngx_http_top_body_filter 这个函数每个请求可能会被执行多次，它的入口函数是 ngx_http_output_filter，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ngx_int_t</span><br><span class="line">ngx_http_output_filter(ngx_http_request_t *r, ngx_chain_t *in)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_int_t          rc;</span><br><span class="line">    ngx_connection_t  *c;</span><br><span class="line"></span><br><span class="line">    c = r-&gt;connection;</span><br><span class="line"></span><br><span class="line">    rc = ngx_http_top_body_filter(r, in);</span><br><span class="line"></span><br><span class="line">    if (rc == NGX_ERROR) &#123;</span><br><span class="line">        /* NGX_ERROR may be returned by any filter */</span><br><span class="line">        c-&gt;error = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ngx_http_output_filter 可以被一般的静态处理模块调用，也有可能是在 upstream 模块里面被调用，对于整个请求的处理阶段来说，他们处于的用处都是一样的，就是把响应内容过滤，然后发给客户端。</p>
<p>具体模块的响应体过滤函数的格式类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int </span><br><span class="line">ngx_http_example_body_filter(ngx_http_request_t *r, ngx_chain_t *in)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return ngx_http_next_body_filter(r, in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的返回值一般是 NGX_OK，NGX_ERROR 和 NGX_AGAIN，分别表示处理成功，失败和未完成。</p>
<h2 id="主要功能介绍"><a href="#主要功能介绍" class="headerlink" title="主要功能介绍"></a>主要功能介绍</h2><p>响应的主体内容就存于单链表 in，链表一般不会太长，有时 in 参数可能为 NULL。in中存有buf结构体中，对于静态文件，这个buf大小默认是 32K；对于反向代理的应用，这个buf可能是4k或者8k。为了保持内存的低消耗，Nginx一般不会分配过大的内存，处理的原则是收到一定的数据，就发送出去。一个简单的例子，可以看看Nginx的chunked_filter模块，在没有 content-length 的情况下，chunk 模块可以流式（stream）的加上长度，方便浏览器接收和显示内容。</p>
<p>在响应体过滤模块中，尤其要注意的是 buf 的标志位，完整描述可以在“相关结构体”这个节中看到。如果 buf 中包含 last 标志，说明是最后一块 buf，可以直接输出并结束请求了。如果有 flush 标志，说明这块 buf 需要马上输出，不能缓存。如果整块 buffer 经过处理完以后，没有数据了，你可以把 buffer 的 sync 标志置上，表示只是同步的用处。</p>
<p>当所有的过滤模块都处理完毕时，在最后的 write_fitler 模块中，Nginx 会将 in 输出链拷贝到 r-&gt;out 输出链的末尾，然后调用 sendfile 或者 writev 接口输出。由于 Nginx 是非阻塞的 socket 接口，写操作并不一定会成功，可能会有部分数据还残存在 r-&gt;out。在下次的调用中，Nginx 会继续尝试发送，直至成功。</p>
<h2 id="发出子请求"><a href="#发出子请求" class="headerlink" title="发出子请求"></a>发出子请求</h2><p>Nginx 过滤模块一大特色就是可以发出子请求，也就是在过滤响应内容的时候，你可以发送新的请求，Nginx 会根据你调用的先后顺序，将多个回复的内容拼接成正常的响应主体。一个简单的例子可以参考 addition 模块。</p>
<p>Nginx 是如何保证父请求和子请求的顺序呢？当 Nginx 发出子请求时，就会调用 ngx_http_subrequest 函数，将子请求插入父请求的 r-&gt;postponed 链表中。子请求会在主请求执行完毕时获得依次调用。子请求同样会有一个请求所有的生存期和处理过程，也会进入过滤模块流程。</p>
<p>关键点是在 postpone_filter 模块中，它会拼接主请求和子请求的响应内容。r-&gt;postponed 按次序保存有父请求和子请求，它是一个链表，如果前面一个请求未完成，那后一个请求内容就不会输出。当前一个请求完成时并输出时，后一个请求才可输出，当所有的子请求都完成时，所有的响应内容也就输出完毕了。</p>
<h2 id="一些优化措施"><a href="#一些优化措施" class="headerlink" title="一些优化措施"></a>一些优化措施</h2><p>Nginx 过滤模块涉及到的结构体，主要就是 chain 和 buf，非常简单。在日常的过滤模块中，这两类结构使用非常频繁，Nginx采用类似 freelist 重复利用的原则，将使用完毕的 chain 或者 buf 结构体，放置到一个固定的空闲链表里，以待下次使用。</p>
<p>比如，在通用内存池结构体中，pool-&gt;chain 变量里面就保存着释放的 chain。而一般的 buf 结构体，没有模块间公用的空闲链表池，都是保存在各模块的缓存空闲链表池里面。对于 buf 结构体，还有一种 busy 链表，表示该链表中的 buf 都处于输出状态，如果 buf 输出完毕，这些 buf 就可以释放并重复利用了。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>函数名</th>
</tr>
</thead>
<tbody>
<tr>
<td>chain 分配</td>
<td>ngx_alloc_chain_link</td>
</tr>
<tr>
<td>chain 释放</td>
<td>ngx_free_chain</td>
</tr>
<tr>
<td>buf 分配</td>
<td>ngx_chain_get_free_buf</td>
</tr>
<tr>
<td>buf 释放</td>
<td>ngx_chain_update_chains</td>
</tr>
</tbody>
</table>
<h2 id="过滤内容的缓存"><a href="#过滤内容的缓存" class="headerlink" title="过滤内容的缓存"></a>过滤内容的缓存</h2><p>由于 Nginx 设计流式的输出结构，当我们需要对响应内容作全文过滤的时候，必须缓存部分的 buf 内容。该类过滤模块往往比较复杂，比如 sub，ssi，gzip 等模块。这类模块的设计非常灵活，我简单讲一下设计原则：</p>
<ol>
<li>输入链 in 需要拷贝操作，经过缓存的过滤模块，输入输出链往往已经完全不一样了，所以需要拷贝，通过 ngx_chain_add_copy 函数完成。</li>
<li>一般有自己的 free 和 busy 缓存链表池，可以提高 buf 分配效率。</li>
<li>如果需要分配大块内容，一般分配固定大小的内存卡，并设置 recycled 标志，表示可以重复利用。</li>
<li>原有的输入 buf 被替换缓存时，必须将其 buf-&gt;pos 设为 buf-&gt;last，表明原有的 buf 已经被输出完毕。或者在新建立的 buf，将 buf-&gt;shadow 指向旧的 buf，以便输出完毕时及时释放旧的 buf。</li>
</ol>
<h1 id="Nginx-upstream-模块简介"><a href="#Nginx-upstream-模块简介" class="headerlink" title="Nginx upstream 模块简介"></a>Nginx upstream 模块简介</h1><p>由 小路依依 创建，Loen 最后一次修改 2016-08-12</p>
<h2 id="upstream-模块简介"><a href="#upstream-模块简介" class="headerlink" title="upstream 模块简介"></a>upstream 模块简介</h2><p>Nginx 模块一般被分成三大类：handler、filter 和 upstream。前面的章节中，读者已经了解了 handler、filter。利用这两类模块，可以使 Nginx 轻松完成任何单机工作。而本章介绍的 upstream 模块，将使 Nginx 跨越单机的限制，完成网络数据的接收、处理和转发。</p>
<p>数据转发功能，为 Nginx 提供了跨越单机的横向处理能力，使 Nginx 摆脱只能为终端节点提供单一功能的限制，而使它具备了网路应用级别的拆分、封装和整合的战略功能。在云模型大行其道的今天，数据转发是 Nginx 有能力构建一个网络应用的关键组件。当然，鉴于开发成本的问题，一个网络应用的关键组件一开始往往会采用高级编程语言开发。但是当系统到达一定规模，并且需要更重视性能的时候，为了达到所要求的性能目标，高级语言开发出的组件必须进行结构化修改。此时，对于修改代价而言，Nginx 的 upstream 模块呈现出极大的吸引力，因为它天生就快。作为附带，Nginx 的配置系统提供的层次化和松耦合使得系统的扩展性也达到比较高的程度。</p>
<p>言归正传，下面介绍 upstream 的写法。</p>
<h2 id="upstream-模块接口"><a href="#upstream-模块接口" class="headerlink" title="upstream 模块接口"></a>upstream 模块接口</h2><p>从本质上说，upstream 属于 handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容，所以才称为 upstream（上游）。请求并取得响应内容的整个过程已经被封装到 Nginx 内部，所以 upstream 模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。</p>
<p>这些回调函数如下表所示：</p>
<table>
<thead>
<tr>
<th>SN</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>create_request</td>
<td>生成发送到后端服务器的请求缓冲（缓冲链），在初始化 upstream 时使用。</td>
</tr>
<tr>
<td>reinit_request</td>
<td>在某台后端服务器出错的情况，Nginx会尝试另一台后端服务器。Nginx 选定新的服务器以后，会先调用此函数，以重新初始化 upstream 模块的工作状态，然后再次进行 upstream 连接。</td>
</tr>
<tr>
<td>process_header</td>
<td>处理后端服务器返回的信息头部。所谓头部是与 upstreamserver 通信的协议规定的，比如 HTTP 协议的 header 部分，或者 memcached 协议的响应状态部分。</td>
</tr>
<tr>
<td>abort_request</td>
<td>在客户端放弃请求时被调用。不需要在函数中实现关闭后端服务器连接的功能，系统会自动完成关闭连接的步骤，所以一般此函数不会进行任何具体工作。</td>
</tr>
<tr>
<td>finalize_request</td>
<td>正常完成与后端服务器的请求后调用该函数，与 abort_request 相同，一般也不会进行任何具体工作。</td>
</tr>
<tr>
<td>input_filter</td>
<td>处理后端服务器返回的响应正文。Nginx 默认的 input_filter 会将收到的内容封装成为缓冲区链 ngx_chain。该链由 upstream 的 out_bufs 指针域定位，所以开发人员可以在模块以外通过该指针 得到后端服务器返回的正文数据。memcached 模块实现了自己的 input_filter，在后面会具体分析这个模块。</td>
</tr>
<tr>
<td>input_filter_init</td>
<td>初始化 input filter 的上下文。Nginx 默认的 input_filter_init 直接返回。</td>
</tr>
</tbody>
</table>
<h2 id="memcached-模块分析"><a href="#memcached-模块分析" class="headerlink" title="memcached 模块分析"></a>memcached 模块分析</h2><p>memcache 是一款高性能的分布式 cache 系统，得到了非常广泛的应用。memcache 定义了一套私有通信协议，使得不能通过 HTTP 请求来访问 memcache。但协议本身简单高效，而且 memcache 使用广泛，所以大部分现代开发语言和平台都提供了 memcache 支持，方便开发者使用 memcache。</p>
<p>Nginx 提供了 ngx_http_memcached 模块，提供从 memcache 读取数据的功能，而不提供向 memcache 写数据的功能。作为 Web 服务器，这种设计是可以接受的。</p>
<p>下面，我们开始分析 ngx_http_memcached 模块，一窥 upstream 的奥秘。</p>
<h2 id="Handler-模块？"><a href="#Handler-模块？" class="headerlink" title="Handler 模块？"></a>Handler 模块？</h2><p>初看 memcached 模块，大家可能觉得并无特别之处。如果稍微细看，甚至觉得有点像 handler 模块，当大家看到这段代码以后，必定疑惑为什么会跟 handler 模块一模一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);</span><br><span class="line">clcf-&gt;handler = ngx_http_memcached_handler;</span><br></pre></td></tr></table></figure>
<p>因为 upstream 模块使用的就是 handler 模块的接入方式。同时，upstream 模块的指令系统的设计也是遵循 handler 模块的基本规则：配置该模块才会执行该模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; ngx_string(&quot;memcached_pass&quot;),</span><br><span class="line">  NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,</span><br><span class="line">  ngx_http_memcached_pass,</span><br><span class="line">  NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">  0,</span><br><span class="line">  NULL &#125;</span><br></pre></td></tr></table></figure>
<p>所以大家觉得眼熟是好事，说明大家对 Handler 的写法已经很熟悉了。</p>
<h2 id="Upstream-模块"><a href="#Upstream-模块" class="headerlink" title="Upstream 模块"></a>Upstream 模块</h2><p>那么，upstream 模块的特别之处究竟在哪里呢？答案是就在模块处理函数的实现中。upstream 模块的处理函数进行的操作都包含一个固定的流程。在 memcached 的例子中，可以观察 ngx_http_memcached_handler 的代码，可以发现，这个固定的操作流程是：</p>
<ol>
<li>创建 upstream 数据结构。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (ngx_http_upstream_create(r) != NGX_OK) &#123;</span><br><span class="line">    return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>设置模块的 tag 和 schema。schema 现在只会用于日志，tag 会用于 buf_chain 管理。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u = r-&gt;upstream;</span><br><span class="line"></span><br><span class="line">ngx_str_set(&amp;u-&gt;schema, &quot;memcached://&quot;);</span><br><span class="line">u-&gt;output.tag = (ngx_buf_tag_t) &amp;ngx_http_memcached_module;</span><br></pre></td></tr></table></figure>
<ol>
<li>设置 upstream 的后端服务器列表数据结构。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mlcf = ngx_http_get_module_loc_conf(r, ngx_http_memcached_module);</span><br><span class="line">u-&gt;conf = &amp;mlcf-&gt;upstream;</span><br></pre></td></tr></table></figure>
<ol>
<li>设置 upstream 回调函数。在这里列出的代码稍稍调整了代码顺序。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">u-&gt;create_request = ngx_http_memcached_create_request;</span><br><span class="line">u-&gt;reinit_request = ngx_http_memcached_reinit_request;</span><br><span class="line">u-&gt;process_header = ngx_http_memcached_process_header;</span><br><span class="line">u-&gt;abort_request = ngx_http_memcached_abort_request;</span><br><span class="line">u-&gt;finalize_request = ngx_http_memcached_finalize_request;</span><br><span class="line">u-&gt;input_filter_init = ngx_http_memcached_filter_init;</span><br><span class="line">u-&gt;input_filter = ngx_http_memcached_filter;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建并设置 upstream 环境数据结构。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctx = ngx_palloc(r-&gt;pool, sizeof(ngx_http_memcached_ctx_t));</span><br><span class="line">if (ctx == NULL) &#123;</span><br><span class="line">    return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;rest = NGX_HTTP_MEMCACHED_END;</span><br><span class="line">ctx-&gt;request = r;</span><br><span class="line"></span><br><span class="line">ngx_http_set_ctx(r, ctx, ngx_http_memcached_module);</span><br><span class="line"></span><br><span class="line">u-&gt;input_filter_ctx = ctx;</span><br></pre></td></tr></table></figure>
<ol>
<li>完成 upstream 初始化并进行收尾工作。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r-&gt;main-&gt;count++;</span><br><span class="line">ngx_http_upstream_init(r);</span><br><span class="line">return NGX_DONE;</span><br></pre></td></tr></table></figure>
<p>任何 upstream 模块，简单如 memcached，复杂如 proxy、fastcgi 都是如此。不同的 upstream 模块在这 6 步中的最大差别会出现在第 2、3、4、5 上。其中第 2、4 两步很容易理解，不同的模块设置的标志和使用的回调函数肯定不同。第 5 步也不难理解，只有第3步是最为晦涩的，不同的模块在取得后端服务器列表时，策略的差异非常大，有如 memcached 这样简单明了的，也有如 proxy 那样逻辑复杂的。这个问题先记下来，等把memcached剖析清楚了，再单独讨论。</p>
<p>第 6 步是一个常态。将 count 加 1，然后返回 NGX_DONE。Nginx 遇到这种情况，虽然会认为当前请求的处理已经结束，但是不会释放请求使用的内存资源，也不会关闭与客户端的连接。之所以需要这样，是因为 Nginx 建立了 upstream 请求和客户端请求之间一对一的关系，在后续使用 ngx_event_pipe 将 upstream 响应发送回客户端时，还要使用到这些保存着客户端信息的数据结构。这部分会在后面的原理篇做具体介绍，这里不再展开。</p>
<p>将 upstream 请求和客户端请求进行一对一绑定，这个设计有优势也有缺陷。优势就是简化模块开发，可以将精力集中在模块逻辑上，而缺陷同样明显，一对一的设计很多时候都不能满足复杂逻辑的需要。对于这一点，将会在后面的原理篇来阐述。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>前面剖析了 memcached 模块的骨架，现在开始逐个解决每个回调函数。</p>
<ul>
<li>ngx_http_memcached_create_request：很简单的按照设置的内容生成一个 key，接着生成一个“get $key”的请求，放在 r-&gt;upstream-&gt;request_bufs 里面。</li>
<li>ngx_http_memcached_reinit_request：无需初始化。</li>
<li>ngx_http_memcached_abort_request：无需额外操作。</li>
<li>ngx_http_memcached_finalize_request：无需额外操作。</li>
<li>ngx_http_memcached_process_header：模块的业务重点函数。memcache 协议的头部信息被定义为第一行文本，可以找到这段代码证明：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (p = u-&gt;buffer.pos; p &lt; u-&gt;buffer.last; p++) &#123;</span><br><span class="line">    if ( * p == LF) &#123;</span><br><span class="line">    goto found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在已读入缓冲的数据中没有发现 LF(‘\n’)字符，函数返回 NGX_AGAIN，表示头部未完全读入，需要继续读取数据。Nginx 在收到新的数据以后会再次调用该函数。</p>
<p>Nginx 处理后端服务器的响应头时只会使用一块缓存，所有数据都在这块缓存中，所以解析头部信息时不需要考虑头部信息跨越多块缓存的情况。而如果头部过大，不能保存在这块缓存中，Nginx 会返回错误信息给客户端，并记录 error log，提示缓存不够大。</p>
<p>process_header 的重要职责是将后端服务器返回的状态翻译成返回给客户端的状态。例如，在 ngx_http_memcached_process_header 中，有这样几段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r-&gt;headers_out.content_length_n = ngx_atoof(len, p - len - 1);</span><br><span class="line"></span><br><span class="line">u-&gt;headers_in.status_n = 200;</span><br><span class="line">u-&gt;state-&gt;status = 200;</span><br><span class="line"></span><br><span class="line">u-&gt;headers_in.status_n = 404;</span><br><span class="line">u-&gt;state-&gt;status = 404;</span><br></pre></td></tr></table></figure>
<p>u-&gt;state 用于计算 upstream 相关的变量。比如 u-&gt;state-&gt;status 将被用于计算变量“upstream_status”的值。u-&gt;headers_in 将被作为返回给客户端的响应返回状态码。而第一行则是设置返回给客户端的响应的长度。</p>
<p>在这个函数中不能忘记的一件事情是处理完头部信息以后需要将读指针 pos 后移，否则这段数据也将被复制到返回给客户端的响应的正文中，进而导致正文内容不正确。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u-&gt;buffer.pos = p + 1;</span><br></pre></td></tr></table></figure>
<p>process_header 函数完成响应头的正确处理，应该返回 NGX_OK。如果返回 NGX_AGAIN，表示未读取完整数据，需要从后端服务器继续读取数据。返回 NGX_DECLINED 无意义，其他任何返回值都被认为是出错状态，Nginx 将结束 upstream 请求并返回错误信息。</p>
<ul>
<li>ngx_http_memcached_filter_init：修正从后端服务器收到的内容长度。因为在处理 header 时没有加上这部分长度。</li>
<li>ngx_http_memcached_filter：memcached 模块是少有的带有处理正文的回调函数的模块。因为 memcached 模块需要过滤正文末尾 CRLF “END” CRLF，所以实现了自己的 filter 回调函数。处理正文的实际意义是将从后端服务器收到的正文有效内容封装成 ngx_chain_t，并加在 u-&gt;out_bufs 末尾。Nginx 并不进行数据拷贝，而是建立 ngx_buf_t 数据结构指向这些数据内存区，然后由 ngx_chain_t 组织这些 buf。这种实现避免了内存大量搬迁，也是 Nginx 高效的奥秘之一。</li>
</ul>
<h2 id="本节回顾"><a href="#本节回顾" class="headerlink" title="本节回顾"></a>本节回顾</h2><p>这一节介绍了 upstream 模块的基本组成。upstream 模块是从 handler 模块发展而来，指令系统和模块生效方式与 handler 模块无异。不同之处在于，upstream 模块在 handler 函数中设置众多回调函数。实际工作都是由这些回调函数完成的。每个回调函数都是在 upstream 的某个固定阶段执行，各司其职，大部分回调函数一般不会真正用到。upstream 最重要的回调函数是 create_request、process_header 和 input_filter，他们共同实现了与后端服务器的协议的解析部分。</p>
<h1 id="Nginx-负载均衡模块"><a href="#Nginx-负载均衡模块" class="headerlink" title="Nginx 负载均衡模块"></a>Nginx 负载均衡模块</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="负载均衡模块"><a href="#负载均衡模块" class="headerlink" title="负载均衡模块"></a>负载均衡模块</h2><p>负载均衡模块用于从<code>upstream</code>指令定义的后端主机列表中选取一台主机。Nginx 先使用负载均衡模块找到一台主机，再使用 upstream 模块实现与这台主机的交互。为了方便介绍负载均衡模块，做到言之有物，以下选取 Nginx 内置的 ip hash 模块作为实际例子进行分析。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>要了解负载均衡模块的开发方法，首先需要了解负载均衡模块的使用方法。因为负载均衡模块与之前书中提到的模块差别比较大，所以我们从配置入手比较容易理解。</p>
<p>在配置文件中，我们如果需要使用 ip hash 的负载均衡算法。我们需要写一个类似下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line"></span><br><span class="line">    server 192.168.0.1;</span><br><span class="line">    server 192.168.0.2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从配置我们可以看出负载均衡模块的使用场景：</p>
<ol>
<li>核心指令<code>ip_hash</code>只能在 upstream {}中使用。这条指令用于通知 Nginx 使用 ip hash 负载均衡算法。如果没加这条指令，Nginx 会使用默认的 round robin 负载均衡模块。请各位读者对比 handler 模块的配置，是不是有共同点？</li>
<li>upstream {}中的指令可能出现在<code>server</code>指令前，可能出现在<code>server</code>指令后，也可能出现在两条<code>server</code>指令之间。各位读者可能会有疑问，有什么差别么？那么请各位读者尝试下面这个配置：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">    server 192.168.0.1 weight=5;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.0.2 weight=7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>神奇的事情出现了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] invalid parameter &quot;weight=7&quot; in nginx.conf:103</span><br><span class="line">configuration file nginx.conf test failed</span><br></pre></td></tr></table></figure>
<p>可见 ip_hash 指令的确能影响到配置的解析。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>配置决定指令系统，现在就来看 ip_hash 的指令定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static ngx_command_t  ngx_http_upstream_ip_hash_commands[] = &#123;</span><br><span class="line"></span><br><span class="line">    &#123; ngx_string(&quot;ip_hash&quot;),</span><br><span class="line">      NGX_HTTP_UPS_CONF|NGX_CONF_NOARGS,</span><br><span class="line">      ngx_http_upstream_ip_hash,</span><br><span class="line">      0,</span><br><span class="line">      0,</span><br><span class="line">      NULL &#125;,</span><br><span class="line"></span><br><span class="line">    ngx_null_command</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>没有特别的东西，除了指令属性是 NGX_HTTP_UPS_CONF。这个属性表示该指令的适用范围是 upstream{}。</p>
<h2 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h2><p>以从前面的章节得到的经验，大家应该知道这里就是模块的切入点了。负载均衡模块的钩子代码都是有规律的，这里通过 ip_hash 模块来分析这个规律。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static char *</span><br><span class="line">ngx_http_upstream_ip_hash(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_upstream_srv_conf_t  *uscf;</span><br><span class="line"></span><br><span class="line">    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);</span><br><span class="line"></span><br><span class="line">    uscf-&gt;peer.init_upstream = ngx_http_upstream_init_ip_hash;</span><br><span class="line"></span><br><span class="line">    uscf-&gt;flags = NGX_HTTP_UPSTREAM_CREATE</span><br><span class="line">                |NGX_HTTP_UPSTREAM_MAX_FAILS</span><br><span class="line">                |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT</span><br><span class="line">                |NGX_HTTP_UPSTREAM_DOWN;</span><br><span class="line"></span><br><span class="line">    return NGX_CONF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中有两点值得我们注意。一个是 uscf-&gt;flags 的设置，另一个是设置 init_upstream 回调。</p>
<h2 id="设置-uscf-gt-flags"><a href="#设置-uscf-gt-flags" class="headerlink" title="设置 uscf-&gt;flags"></a>设置 uscf-&gt;flags</h2><ol>
<li>NGX_HTTP_UPSTREAM_CREATE：创建标志，如果含有创建标志的话，Nginx 会检查重复创建，以及必要参数是否填写；</li>
<li>NGX_HTTP_UPSTREAM_MAX_FAILS：可以在 server 中使用 max_fails 属性；</li>
<li>NGX_HTTP_UPSTREAM_FAIL_TIMEOUT：可以在 server 中使用 fail_timeout 属性；</li>
<li>NGX_HTTP_UPSTREAM_DOWN：可以在 server 中使用 down 属性；</li>
<li>NGX_HTTP_UPSTREAM_WEIGHT：可以在 server 中使用 weight 属性；</li>
<li>NGX_HTTP_UPSTREAM_BACKUP：可以在 server 中使用 backup 属性。</li>
</ol>
<p>聪明的读者如果联想到刚刚遇到的那个神奇的配置错误，可以得出一个结论：在负载均衡模块的指令处理函数中可以设置并修改 upstream{} 中<code>server</code>指令支持的属性。这是一个很重要的性质，因为不同的负载均衡模块对各种属性的支持情况都是不一样的，那么就需要在解析配置文件的时候检测出是否使用了不支持的负载均衡属性并给出错误提示，这对于提升系统维护性是很有意义的。但是，这种机制也存在缺陷，正如前面的例子所示，没有机制能够追加检查在更新支持属性之前已经配置了不支持属性的<code>server</code>指令。</p>
<h2 id="设置-init-upstream-回调"><a href="#设置-init-upstream-回调" class="headerlink" title="设置 init_upstream 回调"></a>设置 init_upstream 回调</h2><p>Nginx 初始化 upstream 时，会在 ngx_http_upstream_init_main_conf 函数中调用设置的回调函数初始化负载均衡模块。这里不太好理解的是 uscf 的具体位置。通过下面的示意图，说明 upstream 负载均衡模块的配置的内存布局。</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-5-1.png" alt="img"></p>
<p>从图上可以看出，MAIN_CONF 中 ngx_upstream_module 模块的配置项中有一个指针数组 upstreams，数组中的每个元素对应就是配置文件中每一个 upstream{}的信息。更具体的将会在后面的原理篇讨论。</p>
<h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>init_upstream 回调函数执行时需要初始化负载均衡模块的配置，还要设置一个新钩子，这个钩子函数会在 Nginx 处理每个请求时作为初始化函数调用，关于这个新钩子函数的功能，后面会有详细的描述。这里，我们先分析 IP hash 模块初始化配置的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_upstream_init_round_robin(cf, us);</span><br><span class="line">us-&gt;peer.init = ngx_http_upstream_init_ip_hash_peer;</span><br></pre></td></tr></table></figure>
<p>这段代码非常简单：IP hash 模块首先调用另一个负载均衡模块 Round Robin 的初始化函数，然后再设置自己的处理请求阶段初始化钩子。实际上几个负载均衡模块可以组成一条链表，每次都是从链首的模块开始进行处理。如果模块决定不处理，可以将处理权交给链表中的下一个模块。这里，IP hash 模块指定 Round Robin 模块作为自己的后继负载均衡模块，所以在自己的初始化配置函数中也对 Round Robin 模块进行初始化。</p>
<h2 id="初始化请求"><a href="#初始化请求" class="headerlink" title="初始化请求"></a>初始化请求</h2><p>Nginx 收到一个请求以后，如果发现需要访问 upstream，就会执行对应的 peer.init 函数。这是在初始化配置时设置的回调函数。这个函数最重要的作用是构造一张表，当前请求可以使用的 upstream 服务器被依次添加到这张表中。之所以需要这张表，最重要的原因是如果 upstream 服务器出现异常，不能提供服务时，可以从这张表中取得其他服务器进行重试操作。此外，这张表也可以用于负载均衡的计算。之所以构造这张表的行为放在这里而不是在前面初始化配置的阶段，是因为upstream需要为每一个请求提供独立隔离的环境。</p>
<p>为了讨论 peer.init 的核心，我们还是看 IP hash 模块的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r-&gt;upstream-&gt;peer.data = &amp;iphp-&gt;rrp;</span><br><span class="line"></span><br><span class="line">ngx_http_upstream_init_round_robin_peer(r, us);</span><br><span class="line"></span><br><span class="line">r-&gt;upstream-&gt;peer.get = ngx_http_upstream_get_ip_hash_peer;</span><br></pre></td></tr></table></figure>
<p>第一行是设置数据指针，这个指针就是指向前面提到的那张表；</p>
<p>第二行是调用 Round Robin 模块的回调函数对该模块进行请求初始化。面前已经提到，一个负载均衡模块可以调用其他负载均衡模块以提供功能的补充。</p>
<p>第三行是设置一个新的回调函数get。该函数负责从表中取出某个服务器。除了 get 回调函数，还有另一个<code>r-&gt;upstream-&gt;peer.free</code>的回调函数。该函数在 upstream 请求完成后调用，负责做一些善后工作。比如我们需要维护一个 upstream 服务器访问计数器，那么可以在 get 函数中对其加 1，在 free 中对其减 1。如果是 SSL 的话，Nginx 还提供两个回调函数 peer.set_session 和 peer.save_session。一般来说，有两个切入点实现负载均衡算法，其一是在这里，其二是在 get 回调函数中。</p>
<h2 id="peer-get-和-peer-free-回调函数"><a href="#peer-get-和-peer-free-回调函数" class="headerlink" title="peer.get 和 peer.free 回调函数"></a>peer.get 和 peer.free 回调函数</h2><p>这两个函数是负载均衡模块最底层的函数，负责实际获取一个连接和回收一个连接的预备操作。之所以说是预备操作，是因为在这两个函数中，并不实际进行建立连接或者释放连接的动作，而只是执行获取连接的地址或维护连接状态的操作。需要理解的清楚一点，在 peer.get 函数中获取连接的地址信息，并不代表这时连接一定没有被建立，相反的，通过 get 函数的返回值，Nginx 可以了解是否存在可用连接，连接是否已经建立。这些返回值总结如下：</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>说明</th>
<th>Nginx 后续动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>NGX_DONE</td>
<td>得到了连接地址信息，并且连接已经建立。</td>
<td>直接使用连接，发送数据。</td>
</tr>
<tr>
<td>NGX_OK</td>
<td>得到了连接地址信息，但连接并未建立。</td>
<td>建立连接，如连接不能立即建立，设置事件，</td>
</tr>
<tr>
<td></td>
<td></td>
<td>暂停执行本请求，执行别的请求。</td>
</tr>
<tr>
<td>NGX_BUSY</td>
<td>所有连接均不可用。</td>
<td>返回502错误至客户端。</td>
</tr>
</tbody>
</table>
<p>各位读者看到上面这张表，可能会有几个问题浮现出来：</p>
<p>Q: 什么时候连接是已经建立的？</p>
<p>A: 使用后端 keepalive 连接的时候，连接在使用完以后并不关闭，而是存放在一个队列中，新的请求只需要从队列中取出连接，这些连接都是已经准备好的。</p>
<p>Q: 什么叫所有连接均不可用？</p>
<p>A: 初始化请求的过程中，建立了一张表，get 函数负责每次从这张表中不重复的取出一个连接，当无法从表中取得一个新的连接时，即所有连接均不可用。</p>
<p>Q: 对于一个请求，peer.get 函数可能被调用多次么？</p>
<p>A: 正式如此。当某次 peer.get 函数得到的连接地址连接不上，或者请求对应的服务器得到异常响应，Nginx 会执行 ngx_http_upstream_next，然后可能再次调用 peer.get 函数尝试别的连接。upstream 整体流程如下：</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/wk/nginx/chapter-5-2.png" alt="img"></p>
<h2 id="本节回顾-1"><a href="#本节回顾-1" class="headerlink" title="本节回顾"></a>本节回顾</h2><p>这一节介绍了负载均衡模块的基本组成。负载均衡模块的配置区集中在 upstream{}块中。负载均衡模块的回调函数体系是以 init_upstream 为起点，经历 init_peer，最终到达 peer.get 和 peer.free。其中 init_peer 负责建立每个请求使用的 server 列表，peer.get 负责从 server 列表中选择某个 server（一般是不重复选择），而 peer.free 负责 server 释放前的资源释放工作。最后，这一节通过一张图将 upstream 模块和负载均衡模块在请求处理过程中的相互关系展现出来。</p>
<h1 id="Nginx-core-模块"><a href="#Nginx-core-模块" class="headerlink" title="Nginx core 模块"></a>Nginx core 模块</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="core-模块"><a href="#core-模块" class="headerlink" title="core 模块"></a>core 模块</h2><h2 id="Nginx-的启动模块"><a href="#Nginx-的启动模块" class="headerlink" title="Nginx 的启动模块"></a>Nginx 的启动模块</h2><p>启动模块从启动 Nginx 进程开始，做了一系列的初始化工作，源代码位于<code>src/core/nginx.c</code>，从 main 函数开始:</p>
<ul>
<li>时间、正则、错误日志、ssl 等初始化</li>
<li>读入命令行参数</li>
<li>OS 相关初始化</li>
<li>读入并解析配置</li>
<li>核心模块初始化</li>
<li>创建各种暂时文件和目录</li>
<li>创建共享内存</li>
<li>打开 listen 的端口</li>
<li>所有模块初始化</li>
<li>启动 worker 进程</li>
</ul>
<h1 id="Nginx-event-模块"><a href="#Nginx-event-模块" class="headerlink" title="Nginx event 模块"></a>Nginx event 模块</h1><p>由 小路依依 创建， 最后一次修改 2016-08-12</p>
<h2 id="event-模块"><a href="#event-模块" class="headerlink" title="event 模块"></a>event 模块</h2><h2 id="event-的类型和功能"><a href="#event-的类型和功能" class="headerlink" title="event 的类型和功能"></a>event 的类型和功能</h2><p>Nginx 是以 event（事件）处理模型为基础的模块。它为了支持跨平台，抽象出了 event 模块。它支持的 event 处理类型有：AIO（异步IO），/dev/poll（Solaris 和 Unix 特有），epoll（Linux 特有），eventport（Solaris 10 特有），kqueue（BSD 特有），poll，rtsig（实时信号），select 等。</p>
<p>event 模块的主要功能就是，监听 accept 后建立的连接，对读写事件进行添加删除。事件处理模型和 Nginx 的非阻塞 IO 模型结合在一起使用。当 IO 可读可写的时候，相应的读写事件就会被唤醒，此时就会去处理事件的回调函数。</p>
<p>特别对于 Linux，Nginx 大部分 event 采用 epoll EPOLLET（边沿触发）的方法来触发事件，只有 listen 端口的读事件是 EPOLLLT（水平触发）。对于边沿触发，如果出现了可读事件，必须及时处理，否则可能会出现读事件不再触发，连接饿死的情况。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">typedef</span> struct &#123;</span><br><span class="line">        /* 添加删除事件 */</span><br><span class="line">        <span class="attribute">ngx_int_t</span>  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);</span><br><span class="line">        <span class="attribute">ngx_int_t</span>  (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ngx_int_t</span>  (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);</span><br><span class="line">        <span class="attribute">ngx_int_t</span>  (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);</span><br><span class="line"></span><br><span class="line">        /* 添加删除连接，会同时监听读写事件 */</span><br><span class="line">        <span class="attribute">ngx_int_t</span>  (*add_conn)(ngx_connection_t *c);</span><br><span class="line">        <span class="attribute">ngx_int_t</span>  (*del_conn)(ngx_connection_t *c, ngx_uint_t flags);</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ngx_int_t</span>  (*process_changes)(ngx_cycle_t *cycle, ngx_uint_t nowait);</span><br><span class="line">        /* 处理事件的函数 */</span><br><span class="line">        <span class="attribute">ngx_int_t</span>  (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer,</span><br><span class="line">                                   ngx_uint_t flags);</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ngx_int_t</span>  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);</span><br><span class="line">        <span class="attribute">void</span>       (*done)(ngx_cycle_t *cycle);</span><br><span class="line">&#125; ngx_event_actions_t;</span><br></pre></td></tr></table></figure>
<p>上述是 event 处理抽象出来的关键结构体，可以看到，每个 event 处理模型，都需要实现部分功能。最关键的是 add 和 del 功能，就是最基本的添加和删除事件的函数。</p>
<h2 id="accept-锁"><a href="#accept-锁" class="headerlink" title="accept 锁"></a>accept 锁</h2><p>Nginx 是多进程程序，80 端口是各进程所共享的，多进程同时 listen 80 端口，势必会产生竞争，也产生了所谓的“惊群”效应。当内核 accept 一个连接时，会唤醒所有等待中的进程，但实际上只有一个进程能获取连接，其他的进程都是被无效唤醒的。所以 Nginx 采用了自有的一套 accept 加锁机制，避免多个进程同时调用 accept。Nginx 多进程的锁在底层默认是通过 CPU 自旋锁来实现。如果操作系统不支持自旋锁，就采用文件锁。</p>
<p>Nginx 事件处理的入口函数是 ngx_process_events_and_timers()，下面是部分代码，可以看到其加锁的过程：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (ngx_use_accept_mutex) &#123;</span><br><span class="line">        <span class="attribute">if</span> (ngx_accept_disabled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ngx_accept_disabled--;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="section">else</span> &#123;</span><br><span class="line">                <span class="attribute">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="attribute">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">                        <span class="attribute">flags</span> |= NGX_POST_EVENTS;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="section">else</span> &#123;</span><br><span class="line">                        <span class="attribute">if</span> (timer == NGX_TIMER_INFINITE</span><br><span class="line">                                || timer &gt; ngx_accept_mutex_delay)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="attribute">timer</span> = ngx_accept_mutex_delay;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ngx_trylock_accept_mutex()函数里面，如果拿到了锁，Nginx 会把 listen 的端口读事件加入 event 处理，该进程在有新连接进来时就可以进行 accept 了。注意 accept 操作是一个普通的读事件。下面的代码说明了这点：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(void) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line"><span class="attribute">if</span> (ngx_posted_accept_events) &#123;</span><br><span class="line">        ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">        ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ngx_process_events()函数是所有事件处理的入口，它会遍历所有的事件。抢到了 accept 锁的进程跟一般进程稍微不同的是，它被加上了 NGX_POST_EVENTS 标志，也就是说在 ngx_process_events() 函数里面只接受而不处理事件，并加入 post_events 的队列里面。直到 ngx_accept_mutex 锁去掉以后才去处理具体的事件。为什么这样？因为 ngx_accept_mutex 是全局锁，这样做可以尽量减少该进程抢到锁以后，从 accept 开始到结束的时间，以便其他进程继续接收新的连接，提高吞吐量。</p>
<p>ngx_posted_accept_events 和 ngx_posted_events 就分别是 accept 延迟事件队列和普通延迟事件队列。可以看到 ngx_posted_accept_events 还是放到 ngx_accept_mutex 锁里面处理的。该队列里面处理的都是 accept 事件，它会一口气把内核 backlog 里等待的连接都 accept 进来，注册到读写事件里。</p>
<p>而 ngx_posted_events 是普通的延迟事件队列。一般情况下，什么样的事件会放到这个普通延迟队列里面呢？我的理解是，那些 CPU 耗时比较多的都可以放进去。因为 Nginx 事件处理都是根据触发顺序在一个大循环里依次处理的，因为 Nginx 一个进程同时只能处理一个事件，所以有些耗时多的事件会把后面所有事件的处理都耽搁了。</p>
<p>除了加锁，Nginx 也对各进程的请求处理的均衡性作了优化，也就是说，如果在负载高的时候，进程抢到的锁过多，会导致这个进程被禁止接受请求一段时间。</p>
<p>比如，在 ngx_event_accept 函数中，有类似代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx_accept_disabled = ngx_cycle-&gt;connection_n / 8</span><br><span class="line">              - ngx_cycle-&gt;free_connection_n;</span><br></pre></td></tr></table></figure>
<p>ngx_cycle-&gt;connection_n 是进程可以分配的连接总数，ngx_cycle-&gt;free_connection_n 是空闲的进程数。上述等式说明了，当前进程的空闲进程数小于 1/8 的话，就会被禁止 accept 一段时间。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>Nginx 在需要用到超时的时候，都会用到定时器机制。比如，建立连接以后的那些读写超时。Nginx 使用红黑树来构造定期器，红黑树是一种有序的二叉平衡树，其查找插入和删除的复杂度都为 O(logn)，所以是一种比较理想的二叉树。</p>
<p>定时器的机制就是，二叉树的值是其超时时间，每次查找二叉树的最小值，如果最小值已经过期，就删除该节点，然后继续查找，直到所有超时节点都被删除。</p>
      
    </div>
    
    
    
	<div>
      
        

      
	</div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持是作者最大的动力</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="xiaoerguang 请我喝杯咖啡！">
        <p>请我喝杯咖啡！</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    xiaoerguang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xiaoerguang.top/p/e30a.html" title="nginx">http://xiaoerguang.top/p/e30a.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/nginx/" rel="tag"># -nginx</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/p/ce6.html" rel="next" title="Nginx 配置文件nginx.conf中文详解">
                <i class="fa fa-chevron-left"></i> Nginx 配置文件nginx.conf中文详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/p/9292.html" rel="prev" title="java23种设计模式">
                java23种设计模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="xiaoerguang">
            
              <p class="site-author-name" itemprop="name">xiaoerguang</p>
              <p class="site-description motion-element" itemprop="description">小二光的博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yongguang1990/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:597688988@qq.com" target="_blank" title="QQ邮箱">
                      
                        <i class="fa fa-fw fa-envelope"></i>QQ邮箱</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.cnblogs.com/yongguang1990/" target="_blank" title="博客园">
                      
                        <i class="fa fa-fw fa-google"></i>博客园</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/my/m/music/playlist?id=152709328" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-twitter"></i>网易云音乐</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/5726729706/profile?rightmod=1&wvr=6&mod=personinfo&is_a" target="_blank" title="新浪微博">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>新浪微博</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://maoyanping.com" title="毛毛的博客" target="_blank">毛毛的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/maomaoyp" title="毛毛的Github" target="_blank">毛毛的Github</a>
                  </li>
                
              </ul>
            </div>
          

          
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是-Nginx"><span class="nav-number">1.</span> <span class="nav-text">什么是 Nginx</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-Nginx-1"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 Nginx</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-的特点"><span class="nav-number">2.</span> <span class="nav-text">Nginx 的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx-特点"><span class="nav-number">2.1.</span> <span class="nav-text">Nginx 特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初探-Nginx-架构"><span class="nav-number">3.</span> <span class="nav-text">初探 Nginx 架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#初探-Nginx-架构-1"><span class="nav-number">3.1.</span> <span class="nav-text">初探 Nginx 架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-基础概念"><span class="nav-number">4.</span> <span class="nav-text">Nginx 基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx-基础概念-1"><span class="nav-number">4.1.</span> <span class="nav-text">Nginx 基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#connection"><span class="nav-number">4.2.</span> <span class="nav-text">connection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#request"><span class="nav-number">4.3.</span> <span class="nav-text">request</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keepalive"><span class="nav-number">4.4.</span> <span class="nav-text">keepalive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pipe"><span class="nav-number">4.5.</span> <span class="nav-text">pipe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lingering-close"><span class="nav-number">4.6.</span> <span class="nav-text">lingering_close</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-基本数据结构"><span class="nav-number">5.</span> <span class="nav-text">Nginx 基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据结构"><span class="nav-number">5.1.</span> <span class="nav-text">基本数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-str-t"><span class="nav-number">5.2.</span> <span class="nav-text">ngx_str_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-pool-t"><span class="nav-number">5.3.</span> <span class="nav-text">ngx_pool_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-array-t"><span class="nav-number">5.4.</span> <span class="nav-text">ngx_array_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-hash-t"><span class="nav-number">5.5.</span> <span class="nav-text">ngx_hash_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-hash-wildcard-t"><span class="nav-number">5.6.</span> <span class="nav-text">ngx_hash_wildcard_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-hash-combined-t"><span class="nav-number">5.7.</span> <span class="nav-text">ngx_hash_combined_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-hash-keys-arrays-t"><span class="nav-number">5.8.</span> <span class="nav-text">ngx_hash_keys_arrays_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-chain-t"><span class="nav-number">5.9.</span> <span class="nav-text">ngx_chain_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-buf-t"><span class="nav-number">5.10.</span> <span class="nav-text">ngx_buf_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-list-t"><span class="nav-number">5.11.</span> <span class="nav-text">ngx_list_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ngx-queue-t"><span class="nav-number">5.12.</span> <span class="nav-text">ngx_queue_t</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-的配置系统"><span class="nav-number">6.</span> <span class="nav-text">Nginx 的配置系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx-的配置系统-1"><span class="nav-number">6.1.</span> <span class="nav-text">Nginx 的配置系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令概述"><span class="nav-number">6.2.</span> <span class="nav-text">指令概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令参数"><span class="nav-number">6.3.</span> <span class="nav-text">指令参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令上下文"><span class="nav-number">6.4.</span> <span class="nav-text">指令上下文</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-的模块化体系结构"><span class="nav-number">7.</span> <span class="nav-text">Nginx 的模块化体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx-的模块化体系结构-1"><span class="nav-number">7.1.</span> <span class="nav-text">Nginx 的模块化体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块概述"><span class="nav-number">7.2.</span> <span class="nav-text">模块概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块的分类"><span class="nav-number">7.3.</span> <span class="nav-text">模块的分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-的请求处理"><span class="nav-number">8.</span> <span class="nav-text">Nginx 的请求处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx-的请求处理-1"><span class="nav-number">8.1.</span> <span class="nav-text">Nginx 的请求处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求的处理流程"><span class="nav-number">8.2.</span> <span class="nav-text">请求的处理流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-handler-模块简介"><span class="nav-number">9.</span> <span class="nav-text">Nginx handler 模块简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#handler-模块简介"><span class="nav-number">9.1.</span> <span class="nav-text">handler 模块简介</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-模块的基本结构"><span class="nav-number">10.</span> <span class="nav-text">Nginx 模块的基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模块的基本结构"><span class="nav-number">10.1.</span> <span class="nav-text">模块的基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块配置结构"><span class="nav-number">10.2.</span> <span class="nav-text">模块配置结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块配置指令"><span class="nav-number">10.3.</span> <span class="nav-text">模块配置指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块上下文结构"><span class="nav-number">10.4.</span> <span class="nav-text">模块上下文结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块的定义"><span class="nav-number">10.5.</span> <span class="nav-text">模块的定义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-handler-模块的基本结构"><span class="nav-number">11.</span> <span class="nav-text">Nginx handler 模块的基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#handler-模块的基本结构"><span class="nav-number">11.1.</span> <span class="nav-text">handler 模块的基本结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-handler-模块的挂载"><span class="nav-number">12.</span> <span class="nav-text">Nginx handler 模块的挂载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#handler-模块的挂载"><span class="nav-number">12.1.</span> <span class="nav-text">handler 模块的挂载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#按处理阶段挂载"><span class="nav-number">12.2.</span> <span class="nav-text">按处理阶段挂载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#按需挂载"><span class="nav-number">12.3.</span> <span class="nav-text">按需挂载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-handler-的编写步骤"><span class="nav-number">13.</span> <span class="nav-text">Nginx handler 的编写步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#handler-的编写步骤"><span class="nav-number">13.1.</span> <span class="nav-text">handler 的编写步骤</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-示例-hello-handler-模块"><span class="nav-number">14.</span> <span class="nav-text">Nginx 示例: hello handler 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#示例-hello-handler-模块"><span class="nav-number">14.1.</span> <span class="nav-text">示例: hello handler 模块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-handler-模块的编译和使用"><span class="nav-number">15.</span> <span class="nav-text">Nginx handler 模块的编译和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#handler-模块的编译和使用"><span class="nav-number">15.1.</span> <span class="nav-text">handler 模块的编译和使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#config-文件的编写"><span class="nav-number">15.2.</span> <span class="nav-text">config 文件的编写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译"><span class="nav-number">15.3.</span> <span class="nav-text">编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用"><span class="nav-number">15.4.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-更多-handler-模块示例分析"><span class="nav-number">16.</span> <span class="nav-text">Nginx 更多 handler 模块示例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#更多-handler-模块示例分析"><span class="nav-number">16.1.</span> <span class="nav-text">更多 handler 模块示例分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-access-module"><span class="nav-number">16.2.</span> <span class="nav-text">http access module</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-static-module"><span class="nav-number">16.3.</span> <span class="nav-text">http static module</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-log-module"><span class="nav-number">16.4.</span> <span class="nav-text">http log module</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-过滤模块简介"><span class="nav-number">17.</span> <span class="nav-text">Nginx 过滤模块简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤模块简介"><span class="nav-number">17.1.</span> <span class="nav-text">过滤模块简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行时间和内容"><span class="nav-number">17.2.</span> <span class="nav-text">执行时间和内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行顺序"><span class="nav-number">17.3.</span> <span class="nav-text">执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块编译"><span class="nav-number">17.4.</span> <span class="nav-text">模块编译</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-过滤模块的分析"><span class="nav-number">18.</span> <span class="nav-text">Nginx 过滤模块的分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤模块的分析"><span class="nav-number">18.1.</span> <span class="nav-text">过滤模块的分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关结构体"><span class="nav-number">18.2.</span> <span class="nav-text">相关结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#响应头过滤函数"><span class="nav-number">18.3.</span> <span class="nav-text">响应头过滤函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#响应体过滤函数"><span class="nav-number">18.4.</span> <span class="nav-text">响应体过滤函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主要功能介绍"><span class="nav-number">18.5.</span> <span class="nav-text">主要功能介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发出子请求"><span class="nav-number">18.6.</span> <span class="nav-text">发出子请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些优化措施"><span class="nav-number">18.7.</span> <span class="nav-text">一些优化措施</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤内容的缓存"><span class="nav-number">18.8.</span> <span class="nav-text">过滤内容的缓存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-upstream-模块简介"><span class="nav-number">19.</span> <span class="nav-text">Nginx upstream 模块简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#upstream-模块简介"><span class="nav-number">19.1.</span> <span class="nav-text">upstream 模块简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#upstream-模块接口"><span class="nav-number">19.2.</span> <span class="nav-text">upstream 模块接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memcached-模块分析"><span class="nav-number">19.3.</span> <span class="nav-text">memcached 模块分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler-模块？"><span class="nav-number">19.4.</span> <span class="nav-text">Handler 模块？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Upstream-模块"><span class="nav-number">19.5.</span> <span class="nav-text">Upstream 模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回调函数"><span class="nav-number">19.6.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本节回顾"><span class="nav-number">19.7.</span> <span class="nav-text">本节回顾</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-负载均衡模块"><span class="nav-number">20.</span> <span class="nav-text">Nginx 负载均衡模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#负载均衡模块"><span class="nav-number">20.1.</span> <span class="nav-text">负载均衡模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置"><span class="nav-number">20.2.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令"><span class="nav-number">20.3.</span> <span class="nav-text">指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#钩子"><span class="nav-number">20.4.</span> <span class="nav-text">钩子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置-uscf-gt-flags"><span class="nav-number">20.5.</span> <span class="nav-text">设置 uscf-&gt;flags</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置-init-upstream-回调"><span class="nav-number">20.6.</span> <span class="nav-text">设置 init_upstream 回调</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化配置"><span class="nav-number">20.6.1.</span> <span class="nav-text">初始化配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化请求"><span class="nav-number">20.7.</span> <span class="nav-text">初始化请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#peer-get-和-peer-free-回调函数"><span class="nav-number">20.8.</span> <span class="nav-text">peer.get 和 peer.free 回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本节回顾-1"><span class="nav-number">20.9.</span> <span class="nav-text">本节回顾</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-core-模块"><span class="nav-number">21.</span> <span class="nav-text">Nginx core 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#core-模块"><span class="nav-number">21.1.</span> <span class="nav-text">core 模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx-的启动模块"><span class="nav-number">21.2.</span> <span class="nav-text">Nginx 的启动模块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx-event-模块"><span class="nav-number">22.</span> <span class="nav-text">Nginx event 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#event-模块"><span class="nav-number">22.1.</span> <span class="nav-text">event 模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#event-的类型和功能"><span class="nav-number">22.2.</span> <span class="nav-text">event 的类型和功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#accept-锁"><span class="nav-number">22.3.</span> <span class="nav-text">accept 锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时器"><span class="nav-number">22.4.</span> <span class="nav-text">定时器</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2014-8 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoerguang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">全站文章总字数&#58;</span>
    
    <span title="全站文章总字数">111.2k</span>
  
</div>
<div class="powered-by">
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共111.2k字</span>
</div><br>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 全程赞助</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '3gLkeiJSti8dBz2ytIbTaSHt-gzGzoHsz',
        appKey: 'zVwFJfjHmp6s5EdD9qER5Hw6',
        placeholder: '陈独秀你坐下！',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("3gLkeiJSti8dBz2ytIbTaSHt-gzGzoHsz", "zVwFJfjHmp6s5EdD9qER5Hw6");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":100,"height":200},"mobile":{"show":true},"log":false});</script></body>
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
